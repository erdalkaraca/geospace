import{$ as w,a0 as f,a1 as M,a2 as g,a3 as d,a4 as L,O as u,a5 as v,a6 as h,a7 as m,a8 as S,a9 as D,aa as E,ab as b,ac as O,ad as F,ae as T,af as k,J as C}from"./index-BxtD-MWy.js";const I=async o=>{var a;const e={interactions:f({keyboard:!1}),controls:w((a=o.mapOptions)==null?void 0:a.controls)},t=o.modules?async i=>o.modules[i]:void 0,r=await M(o.gsMap,e,o.env,t),s=typeof o.containerSelector=="string"?document.querySelector(o.containerSelector):o.containerSelector;return r.setTarget(s),r};class V{constructor(e,t){this.isDestroyed=!1,this.gsMap=e,this.env=t}async reattached(){}async render(e){try{this.olMap=await I({containerSelector:e,gsMap:this.gsMap,env:this.env,mapOptions:{controls:{zoom:!1,attribution:!1}}}),this.operations=new A(this.olMap,this),this.olMap&&(this.olMap.getLayers().getArray().forEach(t=>{g.bindToLayer(t)}),this.olMap.once("rendercomplete",()=>{this.setupEventListeners()}))}catch(t){throw console.error("Failed to render map:",t),t}}async modelToUI(e){if(!this.olMap)throw new Error("Map not initialized");e&&(this.gsMap=e);const t=this.olMap.getTarget();if(!t||typeof t=="string")throw new Error("Map container not found or invalid");this.destroy(),t.innerHTML="",this.isDestroyed=!1,await this.render(t)}getOperations(){if(!this.operations)throw new Error("Operations not available - map not rendered yet");return this.operations}getViewExtent(){if(!this.olMap)throw new Error("OpenLayers map not available for extent calculation");return this.olMap.getView().calculateExtent()}setOnDirty(e){this.onDirtyCallback=e}setOnSync(e){this.onSyncCallback=e}triggerDirty(){this.isDestroyed||!this.onDirtyCallback||this.onDirtyCallback()}triggerSync(){this.isDestroyed||!this.onSyncCallback||this.onSyncCallback(this.gsMap)}syncViewToModel(){if(!this.olMap)return;const e=this.olMap.getView(),t=e.getCenter(),r=e.getZoom(),s=e.getProjection().getCode();t&&(this.gsMap.view.center=t),r!==void 0&&(this.gsMap.view.zoom=r),s&&(this.gsMap.view.projection=s),this.triggerSync()}syncLayerFeaturesToModel(e){if(!this.olMap)return;const r=this.olMap.getLayers().item(e);if(!(r instanceof d))return;const s=r.getSource();if(!s)return;const i=s.getFeatures().map(l=>L(l)),n=this.gsMap.layers[e];n&&n.source.type===u.Features&&(n.source.features=i),this.triggerSync()}setupEventListeners(){this.olMap&&(this.olMap.getView().on("change:center",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getView().on("change:resolution",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getView().on("change:rotation",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getLayers().on("add",()=>this.triggerDirty()),this.olMap.getLayers().on("remove",()=>this.triggerDirty()),this.olMap.getControls().on("add",()=>this.triggerDirty()),this.olMap.getControls().on("remove",()=>this.triggerDirty()),this.olMap.getOverlays().on("add",()=>this.triggerDirty()),this.olMap.getOverlays().on("remove",()=>this.triggerDirty()))}destroy(){var e;this.isDestroyed=!0,(e=this.olMap)==null||e.dispose(),this.olMap=void 0}}class A{constructor(e,t){if(this.olMap=e,this.renderer=t,!e)throw new Error("OpenLayers map is required for operations")}async setZoom(e){this.olMap.getView().setZoom(e)}async setCenter(e){this.olMap.getView().setCenter(e)}async switchColorMode(e){const t=this.olMap;let r=t.get("darkmode")??!1;e==="dark"?r=!0:e==="light"?r=!1:r=!r,t.set("darkmode",r),document.querySelectorAll("canvas").forEach(a=>{a.style.filter=r?"invert(100%)":""}),t.render()}async addLayer(e,t){const r=v(e);t?this.olMap.getLayers().insertAt(0,r):this.olMap.getLayers().push(r),g.bindToLayer(r)}async deleteLayer(e){this.olMap.getLayers().removeAt(e)}async renameLayer(e,t){const r=this.olMap.getLayers();e>=0&&e<r.getLength()&&r.item(e).set(h,t)}async moveLayer(e,t){const r=this.olMap.getLayers();if(e>=0&&e<r.getLength()&&t>=0&&t<r.getLength()&&e!==t){const s=r.item(e);r.removeAt(e),r.insertAt(t,s)}}async setLayerVisible(e,t){const r=this.olMap.getLayers();e>=0&&e<r.getLength()&&r.item(e).setVisible(t)}async applyStyles(e,t){const r=this.olMap.getLayers();let s;if(typeof e=="number"||typeof e=="string"&&e.trim().match(/\d+/)){const a=parseInt(e.toString())-1;a>=0&&a<r.getLength()&&(s=r.item(a))}else{const a=e.toString().trim().toLowerCase();for(let i=0;i<r.getLength();i++){const n=r.item(i);if(n.get(h)===a){s=n;break}}}if(!s)throw new Error(`Layer not found: ${e}`);g.bindToLayer(s)}async addMarker(e,t){var n;const r=t||"geocoded-markers",s=this.olMap.getLayers();let a=s.getArray().find(l=>l.get(h)===r);a||(a=new d({source:new m,[h]:r}),s.push(a));const i=S(e);(n=a.getSource())==null||n.addFeature(i)}async addControlFromModule(e){}async removeControl(e){}async addOverlayFromModule(e,t){}async removeOverlay(e){}async enableDrawing(e,t){this.disableSelection(),this.drawInteraction&&this.olMap.removeInteraction(this.drawInteraction),this.activeDrawingLayerIndex=t;const s=this.olMap.getLayers().item(t);if(!(s instanceof d))throw new Error("Drawing only supported on vector layers");const a=s.getSource();if(!a)throw new Error("Layer has no source");const i=s.get("sourceType");if(i&&i!==u.Features)throw new Error("Drawing only supported on layers with in-memory features, not URL-loaded data");this.drawInteraction=new D({source:a,type:e});const n=()=>{var l;this.renderer&&this.activeDrawingLayerIndex!==void 0&&this.renderer.syncLayerFeaturesToModel(this.activeDrawingLayerIndex),(l=this.renderer)==null||l.triggerDirty()};a.on("addfeature",n),this.drawInteraction._featureAddedListener=n,this.drawInteraction._sourceRef=a,this.olMap.addInteraction(this.drawInteraction)}async disableDrawing(){if(this.drawInteraction){const e=this.drawInteraction._featureAddedListener,t=this.drawInteraction._sourceRef;e&&t&&t.un("addfeature",e),this.olMap.removeInteraction(this.drawInteraction),this.drawInteraction=void 0}}async enableFeatureSelection(e){this.disableDrawing(),this.disableSelection(),this.activeDrawingLayerIndex=e;const r=this.olMap.getLayers().item(e);if(!(r instanceof d))throw new Error("Selection only supported on vector layers");this.activeSelectionLayer=r;const s={condition:b,layers:[r],style:a=>{const i=new O({color:"rgba(255, 255, 0, 1)",width:3}),n=new F({color:"rgba(255, 255, 0, 0.3)"});return new T({image:new k({radius:7,fill:n,stroke:i}),stroke:i,fill:n})}};this.selectInteraction=new E(s),this.olMap.addInteraction(this.selectInteraction)}async deleteSelectedFeatures(){var r,s;if(!this.selectInteraction)throw new Error("No selection interaction active");const e=this.selectInteraction.getFeatures();if(e.getLength()===0)throw new Error("No features selected");const t=(r=this.activeSelectionLayer)==null?void 0:r.getSource();if(!t)throw new Error("No active layer source");e.forEach(a=>{t.removeFeature(a)}),e.clear(),this.renderer&&this.activeDrawingLayerIndex!==void 0&&this.renderer.syncLayerFeaturesToModel(this.activeDrawingLayerIndex),(s=this.renderer)==null||s.triggerDirty()}disableSelection(){this.selectInteraction&&(this.olMap.removeInteraction(this.selectInteraction),this.selectInteraction=void 0,this.activeSelectionLayer=void 0)}}C.resolveUrl=async o=>{try{return await p(o)}catch(e){return console.warn("Failed to resolve asset via host:",e),o}};let c;const y=new Map;let _=0;window.addEventListener("message",o=>{const{id:e,success:t,assetUrl:r,error:s}=o.data;if(y.has(e)){const{resolve:a,reject:i,timeout:n}=y.get(e);clearTimeout(n),y.delete(e),t?a(r):i(new Error(s))}});async function p(o){return new Promise((e,t)=>{const r=`asset_${++_}`,s=setTimeout(()=>{y.delete(r),t(new Error("Asset resolution timeout"))},5e3);y.set(r,{resolve:e,reject:t,timeout:s}),window.parent.postMessage({type:"resolveAsset",id:r,path:o},"*")})}async function U(o,e){switch(o){case"render":return c=new V(e.gsMap,e.env),c.setOnDirty(()=>{window.parent.postMessage({type:"dirty"},"*")}),c.setOnSync(t=>{window.parent.postMessage({type:"sync",gsMap:t},"*")}),await c.render("#map-container"),{success:!0};case"modelToUI":return c&&await c.modelToUI(e),{success:!0};case"getViewExtent":return c?{extent:c.getViewExtent()}:{extent:[0,0,0,0]};case"resolveAsset":try{return{success:!0,assetUrl:await p(e.path)}}catch(t){return{success:!1,error:t.message}}default:if(c&&c.getOperations){const t=c.getOperations();if(t[o]&&typeof t[o]=="function")return await t[o](...Object.values(e||{})),{success:!0}}throw new Error(`Unknown method: ${o}`)}}window.addEventListener("message",async o=>{const{id:e,method:t,params:r}=o.data;let s;try{s=await U(t,r)}catch(a){s={error:a.message}}o.source.postMessage({id:e,...s},o.origin)});document.addEventListener("click",()=>{window.parent.postMessage({type:"iframeClicked"},"*")},!0);window.parent.postMessage({type:"rendererReady"},"*");
