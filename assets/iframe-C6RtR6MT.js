import{K as T,L as O,N as b,V as u,O as D,P as E,Q as I,R as V,S as m,U as A,z as k,W as _,X as R,Y as U,Z as P,$ as j,a0 as N,a1 as q,a2 as S,a3 as z,a4 as Z,a5 as $,u as G}from"./index-8zt1sAbO.js";const K=async o=>{var a;const e={interactions:O({keyboard:!1}),controls:T((a=o.mapOptions)==null?void 0:a.controls)},t=o.modules?async n=>o.modules[n]:void 0,r=await b(o.gsMap,e,o.env,t),s=typeof o.containerSelector=="string"?document.querySelector(o.containerSelector):o.containerSelector;return r.setTarget(s),r};function Y(o){return{geometry:{type:o.getGeometry().getType(),coordinates:[]},state:o.get($)}}class H{constructor(e,t){this.isDestroyed=!1,this.styleCache=new Map,this.gsMap=e,this.env=t}async reattached(){}async render(e){try{this.olMap=await K({containerSelector:e,gsMap:this.gsMap,env:this.env,mapOptions:{controls:{zoom:!1,attribution:!1}}}),this.operations=new x(this.olMap,this),this.applyStylesToLayers(),this.olMap.once("rendercomplete",()=>{this.setupEventListeners()})}catch(t){throw console.error("Failed to render map:",t),t}}applyStylesToLayers(){if(!this.olMap)return;this.olMap.getLayers().getArray().forEach(t=>{t instanceof u&&this.applyStyleToVectorLayer(t)})}applyStyleToVectorLayer(e){const t=e.get(D),r=s=>{if(!(s instanceof I))return;const a=Y(s),n=this.gsMap.styleRules,l=this.gsMap.styles;if(n&&l){const c=V(a,n,l,t);if(c&&c.id){let i=this.styleCache.get(c.id);return i||(i=m(c),this.styleCache.set(c.id,i)),i}else if(c)return m(c)}};e.setStyle(r)}clearStyleCache(){this.styleCache.clear()}async modelToUI(e){if(!this.olMap)throw new Error("Map not initialized");e&&(this.gsMap=e),this.clearStyleCache();const t=this.olMap.getTarget();if(!t||typeof t=="string")throw new Error("Map container not found or invalid");this.destroy(),t.innerHTML="",this.isDestroyed=!1,await this.render(t)}getOperations(){if(!this.operations)throw new Error("Operations not available - map not rendered yet");return this.operations}getViewExtent(){if(!this.olMap)throw new Error("OpenLayers map not available for extent calculation");return this.olMap.getView().calculateExtent()}setOnDirty(e){this.onDirtyCallback=e}setOnSync(e){this.onSyncCallback=e}triggerDirty(){this.isDestroyed||!this.onDirtyCallback||this.onDirtyCallback()}triggerSync(e){this.isDestroyed||!this.onSyncCallback||this.onSyncCallback(e)}syncViewToModel(){if(!this.olMap)return;const e=this.olMap.getView(),t=e.getCenter(),r=e.getZoom(),s=e.getRotation();t&&r!==void 0&&this.triggerSync({type:"viewChanged",view:{center:t,zoom:r,rotation:s}})}syncLayerFeaturesToModel(e){if(!this.olMap)return;const r=this.olMap.getLayers().item(e);if(!(r instanceof u))return;const s=r.getSource();if(!s)return;const n=s.getFeatures().map(l=>E(l));this.triggerSync({type:"featuresChanged",layerIndex:e,features:n})}setupEventListeners(){this.olMap&&(this.olMap.getView().on("change:center",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getView().on("change:resolution",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getView().on("change:rotation",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getLayers().on("add",()=>this.triggerDirty()),this.olMap.getLayers().on("remove",()=>this.triggerDirty()),this.olMap.getControls().on("add",()=>this.triggerDirty()),this.olMap.getControls().on("remove",()=>this.triggerDirty()),this.olMap.getOverlays().on("add",()=>this.triggerDirty()),this.olMap.getOverlays().on("remove",()=>this.triggerDirty()))}destroy(){var e;this.isDestroyed=!0,this.clearStyleCache(),(e=this.olMap)==null||e.dispose(),this.olMap=void 0}}class x{constructor(e,t){if(this.olMap=e,this.renderer=t,!e)throw new Error("OpenLayers map is required for operations")}async setZoom(e){this.olMap.getView().setZoom(e)}async setCenter(e){this.olMap.getView().setCenter(e)}async switchColorMode(e){const t=this.olMap;let r=t.get("darkmode")??!1;e==="dark"?r=!0:e==="light"?r=!1:r=!r,t.set("darkmode",r),document.querySelectorAll("canvas").forEach(a=>{a.style.filter=r?"invert(100%)":""}),t.render()}async addLayer(e,t){const r=A(e);t?this.olMap.getLayers().insertAt(0,r):this.olMap.getLayers().push(r)}async deleteLayer(e){this.olMap.getLayers().removeAt(e)}async renameLayer(e,t){const r=this.olMap.getLayers();e>=0&&e<r.getLength()&&r.item(e).set(D,t)}async moveLayer(e,t){const r=this.olMap.getLayers();if(e>=0&&e<r.getLength()&&t>=0&&t<r.getLength()&&e!==t){const s=r.item(e);r.removeAt(e),r.insertAt(t,s)}}async setLayerVisible(e,t){const r=this.olMap.getLayers();e>=0&&e<r.getLength()&&r.item(e).setVisible(t)}async addControlFromModule(e){}async removeControl(e){}async addOverlayFromModule(e,t){}async removeOverlay(e){}setCursor(e){const t=this.olMap.getViewport();t&&(t.style.cursor=e)}async enableDrawing(e,t){this.disableSelection(),this.drawInteraction&&this.olMap.removeInteraction(this.drawInteraction),this.activeDrawingLayerIndex=t,this.setCursor("crosshair");const s=this.olMap.getLayers().item(t);if(!(s instanceof u))throw new Error("Drawing only supported on vector layers");const a=s.getSource();if(!a)throw new Error("Layer has no source");const n=s.get("sourceType");if(n&&n!==k.Features)throw new Error("Drawing only supported on layers with in-memory features, not URL-loaded data");this.drawInteraction=new _({source:a,type:e});const l=()=>{var c;this.renderer&&this.activeDrawingLayerIndex!==void 0&&this.renderer.syncLayerFeaturesToModel(this.activeDrawingLayerIndex),(c=this.renderer)==null||c.triggerDirty()};a.on("addfeature",l),this.drawInteraction._featureAddedListener=l,this.drawInteraction._sourceRef=a,this.olMap.addInteraction(this.drawInteraction)}async disableDrawing(){if(this.drawInteraction){const e=this.drawInteraction._featureAddedListener,t=this.drawInteraction._sourceRef;e&&t&&t.un("addfeature",e),this.olMap.removeInteraction(this.drawInteraction),this.drawInteraction=void 0,this.setCursor("")}}async enableFeatureSelection(e){var l,c;this.disableDrawing(),this.disableSelection();const t=this.olMap.getLayers(),r=t.getArray().filter(i=>i instanceof u);if(r.length===0)throw new Error("No vector layers available for selection");if(e>=0&&e<t.getLength()){this.activeDrawingLayerIndex=e;const i=t.item(e);i instanceof u&&(this.activeSelectionLayer=i)}const s=(l=this.renderer)==null?void 0:l.gsMap,a=(c=s==null?void 0:s.styles)==null?void 0:c.selection,n={condition:q,layers:r,hitTolerance:5,style:a?m(a):i=>{const p=new R({color:"rgba(255, 255, 0, 1)",width:3}),d=new U({color:"rgba(255, 255, 0, 0.3)"});return new P({image:new j({radius:7,fill:d,stroke:p}),stroke:p,fill:d})}};this.selectInteraction=new N(n),this.selectInteraction.on("select",i=>{var p;if(i.selected.length>0){const d=i.selected[0];let v=-1;if(t.getArray().forEach((L,h)=>{if(L instanceof u){const g=L.getSource();g&&g.hasFeature(d)&&(v=h)}}),v>=0&&this.renderer){const L=E(d),h=d.getGeometry(),g={};if(h){const w=h.getType();try{if(w==="LineString"||w==="MultiLineString")g.length=S(h,{projection:this.olMap.getView().getProjection()});else if(w==="Polygon"||w==="MultiPolygon"){g.area=z(h,{projection:this.olMap.getView().getProjection()});const f=w==="Polygon"?h.getCoordinates()[0]:h.getCoordinates()[0][0];if(f&&f.length>0){const F=new Z(f);g.length=S(F,{projection:this.olMap.getView().getProjection()})}}}catch(f){console.warn("Error calculating feature metrics:",f)}}this.renderer.triggerSync({type:"featureSelected",layerIndex:v,feature:L,metrics:g})}}else i.deselected.length>0&&((p=this.renderer)==null||p.triggerSync({type:"featureDeselected"}))}),this.olMap.addInteraction(this.selectInteraction),this.setCursor("pointer")}async deleteSelectedFeatures(){var r,s;if(!this.selectInteraction)throw new Error("No selection interaction active");const e=this.selectInteraction.getFeatures();if(e.getLength()===0)throw new Error("No features selected");const t=(r=this.activeSelectionLayer)==null?void 0:r.getSource();if(!t)throw new Error("No active layer source");e.forEach(a=>{t.removeFeature(a)}),e.clear(),this.renderer&&this.activeDrawingLayerIndex!==void 0&&this.renderer.syncLayerFeaturesToModel(this.activeDrawingLayerIndex),(s=this.renderer)==null||s.triggerDirty()}async disableSelection(){var e;this.selectInteraction&&(this.olMap.removeInteraction(this.selectInteraction),this.selectInteraction=void 0,this.activeSelectionLayer=void 0,this.setCursor(""),(e=this.renderer)==null||e.triggerSync({type:"featureDeselected"}))}}G.resolveUrl=async o=>{try{return await C(o)}catch(e){return console.warn("Failed to resolve asset via host:",e),o}};let y;const M=new Map;let Q=0;window.addEventListener("message",o=>{const{id:e,success:t,assetUrl:r,error:s}=o.data;if(M.has(e)){const{resolve:a,reject:n,timeout:l}=M.get(e);clearTimeout(l),M.delete(e),t?a(r):n(new Error(s))}});async function C(o){return new Promise((e,t)=>{const r=`asset_${++Q}`,s=setTimeout(()=>{M.delete(r),t(new Error("Asset resolution timeout"))},5e3);M.set(r,{resolve:e,reject:t,timeout:s}),window.parent.postMessage({type:"resolveAsset",id:r,path:o},"*")})}async function W(o,e){switch(o){case"render":return y=new H(e.gsMap,e.env),y.setOnDirty(()=>{window.parent.postMessage({type:"dirty"},"*")}),y.setOnSync(t=>{window.parent.postMessage({type:"sync",event:t},"*")}),await y.render("#map-container"),{success:!0};case"modelToUI":return y&&await y.modelToUI(e),{success:!0};case"getViewExtent":return y?{extent:y.getViewExtent()}:{extent:[0,0,0,0]};case"resolveAsset":try{return{success:!0,assetUrl:await C(e.path)}}catch(t){return{success:!1,error:t.message}}default:if(y&&y.getOperations){const t=y.getOperations();if(t[o]&&typeof t[o]=="function")return await t[o](...Object.values(e||{})),{success:!0}}throw new Error(`Unknown method: ${o}`)}}window.addEventListener("message",async o=>{const{id:e,method:t,params:r}=o.data;let s;try{s=await W(t,r)}catch(a){s={error:a.message}}o.source.postMessage({id:e,...s},o.origin)});document.addEventListener("click",()=>{window.parent.postMessage({type:"iframeClicked"},"*")},!0);window.parent.postMessage({type:"rendererReady"},"*");
