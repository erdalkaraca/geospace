import{M as p,N as u,O as w,P as g,Q as M,S as y,V as f,U as m,X as v,q as L}from"./index-BPeis-MP.js";const O=async r=>{var a;const e={interactions:u({keyboard:!1}),controls:p((a=r.mapOptions)==null?void 0:a.controls)},t=r.modules?async i=>r.modules[i]:void 0,s=await w(r.gsMap,e,r.env,t),o=typeof r.containerSelector=="string"?document.querySelector(r.containerSelector):r.containerSelector;return s.setTarget(o),s};class E{constructor(e,t){this.isDestroyed=!1,this.gsMap=e,this.env=t}async render(e){try{this.olMap=await O({containerSelector:e,gsMap:this.gsMap,env:this.env,mapOptions:{controls:{zoom:!1,attribution:!1}}}),this.operations=new D(this.olMap),this.olMap&&(this.olMap.getLayers().getArray().forEach(t=>{g.bindToLayer(t)}),this.olMap.once("rendercomplete",()=>{this.setupEventListeners()}))}catch(t){throw console.error("Failed to render map:",t),t}}async modelToUI(e){if(!this.olMap)throw new Error("Map not initialized");e&&(this.gsMap=e);const t=this.olMap.getTarget();if(!t||typeof t=="string")throw new Error("Map container not found or invalid");this.destroy(),t.innerHTML="",this.isDestroyed=!1,await this.render(t)}getOperations(){if(!this.operations)throw new Error("Operations not available - map not rendered yet");return this.operations}getViewExtent(){if(!this.olMap)throw new Error("OpenLayers map not available for extent calculation");return this.olMap.getView().calculateExtent()}setOnDirty(e){this.onDirtyCallback=e}setOnSync(e){this.onSyncCallback=e}triggerDirty(){this.isDestroyed||!this.onDirtyCallback||this.onDirtyCallback()}triggerSync(){this.isDestroyed||!this.onSyncCallback||this.onSyncCallback(this.gsMap)}syncViewToModel(){if(!this.olMap)return;const e=this.olMap.getView(),t=e.getCenter(),s=e.getZoom(),o=e.getProjection().getCode();t&&(this.gsMap.view.center=t),s!==void 0&&(this.gsMap.view.zoom=s),o&&(this.gsMap.view.projection=o),this.triggerSync()}setupEventListeners(){this.olMap&&(this.olMap.getView().on("change:center",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getView().on("change:resolution",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getView().on("change:rotation",()=>{this.syncViewToModel(),this.triggerDirty()}),this.olMap.getLayers().on("add",()=>this.triggerDirty()),this.olMap.getLayers().on("remove",()=>this.triggerDirty()),this.olMap.getControls().on("add",()=>this.triggerDirty()),this.olMap.getControls().on("remove",()=>this.triggerDirty()),this.olMap.getOverlays().on("add",()=>this.triggerDirty()),this.olMap.getOverlays().on("remove",()=>this.triggerDirty()))}destroy(){var e;this.isDestroyed=!0,(e=this.olMap)==null||e.dispose(),this.olMap=void 0}}class D{constructor(e){if(this.olMap=e,!e)throw new Error("OpenLayers map is required for operations")}async setZoom(e){this.olMap.getView().setZoom(e)}async setCenter(e){this.olMap.getView().setCenter(e)}async switchColorMode(e){const t=this.olMap;let s=t.get("darkmode")??!1;e==="dark"?s=!0:e==="light"?s=!1:s=!s,t.set("darkmode",s),document.querySelectorAll("canvas").forEach(a=>{a.style.filter=s?"invert(100%)":""}),t.render()}async addLayer(e,t){const s=M(e);t?this.olMap.getLayers().insertAt(0,s):this.olMap.getLayers().push(s),g.bindToLayer(s)}async deleteLayer(e){this.olMap.getLayers().removeAt(e)}async setLayerVisible(e,t){const s=this.olMap.getLayers();e>=0&&e<s.getLength()&&s.item(e).setVisible(t)}async applyStyles(e,t){const s=this.olMap.getLayers();let o;if(typeof e=="number"||typeof e=="string"&&e.trim().match(/\d+/)){const a=parseInt(e.toString())-1;a>=0&&a<s.getLength()&&(o=s.item(a))}else{const a=e.toString().trim().toLowerCase();for(let i=0;i<s.getLength();i++){const l=s.item(i);if(l.get(y)===a){o=l;break}}}if(!o)throw new Error(`Layer not found: ${e}`);g.bindToLayer(o)}async addMarker(e,t){var l;const s=t||"geocoded-markers",o=this.olMap.getLayers();let a=o.getArray().find(d=>d.get(y)===s);a||(a=new f({source:new m,[y]:s}),o.push(a));const i=v(e);(l=a.getSource())==null||l.addFeature(i)}async addControlFromModule(e){}async removeControl(e){}async addOverlayFromModule(e,t){}async removeOverlay(e){}}L.resolveUrl=async r=>{try{return await h(r)}catch(e){return console.warn("Failed to resolve asset via host:",e),r}};let n;const c=new Map;let b=0;window.addEventListener("message",r=>{const{id:e,success:t,assetUrl:s,error:o}=r.data;if(c.has(e)){const{resolve:a,reject:i,timeout:l}=c.get(e);clearTimeout(l),c.delete(e),t?a(s):i(new Error(o))}});async function h(r){return new Promise((e,t)=>{const s=`asset_${++b}`,o=setTimeout(()=>{c.delete(s),t(new Error("Asset resolution timeout"))},5e3);c.set(s,{resolve:e,reject:t,timeout:o}),window.parent.postMessage({type:"resolveAsset",id:s,path:r},"*")})}async function S(r,e){switch(r){case"render":return n=new E(e.gsMap,e.env),n.setOnDirty(()=>{window.parent.postMessage({type:"dirty"},"*")}),n.setOnSync(t=>{window.parent.postMessage({type:"sync",gsMap:t},"*")}),await n.render("#map-container"),{success:!0};case"modelToUI":return n&&await n.modelToUI(e),{success:!0};case"getViewExtent":return n?{extent:n.getViewExtent()}:{extent:[0,0,0,0]};case"resolveAsset":try{return{success:!0,assetUrl:await h(e.path)}}catch(t){return{success:!1,error:t.message}}default:if(n&&n.getOperations){const t=n.getOperations();if(t[r]&&typeof t[r]=="function")return await t[r](...Object.values(e||{})),{success:!0}}throw new Error(`Unknown method: ${r}`)}}window.addEventListener("message",async r=>{const{id:e,method:t,params:s}=r.data;let o;try{o=await S(t,s)}catch(a){o={error:a.message}}r.source.postMessage({id:e,...o},r.origin)});window.parent.postMessage({type:"rendererReady"},"*");
