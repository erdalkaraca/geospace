const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-CUNXveE1.js","assets/preload-helper-WQhrSmCl.js","assets/chunk.LTSJC6DR-BTS7fm5P.js","assets/index-aP6FMjSZ.css"])))=>i.map(i=>d[i]);
import{x as Ye,B as ut}from"./index-CUNXveE1.js";import{w as Qe,l as Jt,t as mt,a as gt,b as je,r as qt,D as wt,c as ft,G as Ht,F as Be,d as dt,e as Yt}from"./geospace-app-DrLdvsxT.js";import{_ as ce,g as Xt}from"./preload-helper-WQhrSmCl.js";import"./chunk.LTSJC6DR-BTS7fm5P.js";import"./chunk.RRCUZAZD-5O78oK5S.js";function Kt(R,_){for(var S=0;S<_.length;S++){const k=_[S];if(typeof k!="string"&&!Array.isArray(k)){for(const F in k)if(F!=="default"&&!(F in R)){const $=Object.getOwnPropertyDescriptor(k,F);$&&Object.defineProperty(R,F,$.get?$:{enumerable:!0,get:()=>k[F]})}}}return Object.freeze(Object.defineProperty(R,Symbol.toStringTag,{value:"Module"}))}function Qt(R){const S=[...R.gsMap.controls||[],...R.gsMap.overlays||[]].map($=>$.src).filter($=>$),k=S.map(($,O)=>{const N=$.replace(/`/g,"\\`").replace(/\$/g,"\\$");return`import script${O} from '${N}'`}),F=S.map(($,O)=>`${JSON.stringify($)}: script${O}`).join(`,
        `);return`
import {gsLib} from "${R.gsLibPath}"
import "./gs-lib/gs-lib.css"

${k.join(`
`)}

export const renderMap = (mapContainerSelector) => {
    const modules = {
        ${F}
    }
    return gsLib({
        containerSelector: mapContainerSelector,
        gsMap: ${JSON.stringify(R.gsMap)},
        mapOptions: {
            controls: {zoom: false, attribution: false}
        },
        env: ${JSON.stringify(R.env||{})},
        modules: modules
    })
}
`}function Zt(R){return JSON.stringify(R,null,2)}function en(R,_){if(_){const S=Zt(_);return R.includes("self.__WB_MANIFEST")?R.replace("self.__WB_MANIFEST || []",`${S}`):R.replace(/workbox\.precaching\.precacheAndRoute\(/,`self.__WB_MANIFEST = ${S};
workbox.precaching.precacheAndRoute(`)}return R}function tn(R,_,S){const k=JSON.parse(R);return k.name=_,k.short_name=_,k.description=_,k.version=S,JSON.stringify(k,null,2)}function nn(R,_,S,k){let F=R.replace(/\$TITLE/g,_);return S&&(F=F.replace(/\.\/app\.js/g,`./${S}`)),k&&(F=F.replace(/href=["']app\.css["']/g,`href="${k}"`)),F}async function rn(R,_,S,k,F,$,O,N,Q){const L=J=>{O&&O(N!==void 0?++N.value:0,J,Q)};L("Bundling and minifying code...");const z=await $.build({entryPoints:[R],bundle:!0,outdir:_,format:"esm",minify:!0,plugins:[F],entryNames:"[name]-[hash]",external:[],packages:"bundle",write:!1,metafile:!0});if(L("Saving bundled output..."),!z.outputFiles||z.outputFiles.length===0)throw new Error("No output files generated by esbuild");let Z=null,ne=null;if(z.metafile&&z.metafile.outputs)for(const[te,fe]of Object.entries(z.metafile.outputs))fe&&typeof fe=="object"&&"entryPoint"in fe&&(te.includes("app")&&te.endsWith(".js")?Z=te:te.endsWith(".css")&&(ne=te));const ge=J=>{const te=Math.max(J.lastIndexOf("/"),J.lastIndexOf("\\"));return te>=0?J.substring(te+1):J};for(const J of z.outputFiles){let te=J.path||"",fe,de;te.startsWith("/")||te.length>2&&te[1]===":"?(de=ge(te),fe=`${_}/${de}`):(de=ge(te),fe=te.startsWith(_)?te:`${_}/${te}`),await k.writeFile(fe,J.contents),!Z&&de.includes("app-")&&de.endsWith(".js")&&(Z=de),!ne&&de.includes("app-")&&de.endsWith(".css")&&(ne=de)}if(!Z)throw new Error("Could not find main output file");return{js:ge(Z),css:ne?ge(ne):null}}function sn(R,_){const S=async(k,F,$,O)=>{const N=`${_}/${k}`;let Q=await R.readFile(N);$&&(Q instanceof Uint8Array?Q=new TextDecoder().decode(Q):Q=Q,O&&(Q=await O(Q))),await R.writeFile(F,Q)};return{async copyTextFile(k,F,$){await S(k,F,!0,$)},async copyBinaryFile(k,F){await S(k,F,!1)}}}async function ln(R,_,S,k,F={},$){const{outputDir:O="dist",buildDir:N="__build",gsLibPath:Q=`${N}/gs-lib/index.js`,gsLibPackagePath:L,gsLibCopier:z,cleanBeforeBuild:Z=!0,cleanAfterBuild:ne=!0,copyAssets:ge}=F,J=z||(L?sn(_,L):null);if(!J)throw new Error("Either gsLibCopier or gsLibPackagePath must be provided");const te=Q;let fe=F.startingStep??0;const de=F.totalSteps,ue=ie=>{$&&$(++fe,ie,de)};if(Z){ue("Cleaning build directories...");const ie=[];if(_.deleteDir)ie.push(_.deleteDir(N).catch(()=>{}),_.deleteDir(O).catch(()=>{}));else try{const _e=await ce(()=>import("./index-CUNXveE1.js").then(we=>we.T),__vite__mapDeps([0,1,2,3])),Ae=await ce(()=>import("./index-CUNXveE1.js").then(we=>we.T),__vite__mapDeps([0,1,2,3])),ke=process.cwd();ie.push(_e.rm(Ae.resolve(ke,N),{recursive:!0,force:!0}).catch(()=>{}),_e.rm(Ae.resolve(ke,O),{recursive:!0,force:!0}).catch(()=>{}))}catch{}await Promise.all(ie)}ue("Preparing build directories..."),await Promise.all([_.ensureDir(`${O}/assets/icons/`),_.ensureDir(`${N}/gs-lib/`)]),ue("Copying gs-lib package..."),await Promise.all([J.copyTextFile("dist/index.js",`${N}/gs-lib/index.js`),J.copyTextFile("dist/gs-lib.css",`${N}/gs-lib/gs-lib.css`)]),ue("Copying PWA core files..."),await J.copyTextFile("public/pwa/staticwebapp.config.json",`${O}/staticwebapp.config.json`),ue("Creating manifest file..."),await J.copyTextFile("public/pwa/manifest.json",`${O}/manifest.json`,ie=>tn(ie,R.title,R.version)),ue("Copying PWA icons...");const se=["24x24.png","48x48.png","192x192.png","512x512.png","icon_24.png","icon_48.png","icon_192.png","icon_512.png"];await Promise.all(se.map(ie=>J.copyBinaryFile(`public/pwa/assets/icons/${ie}`,`${O}/assets/icons/${ie}`))),ge&&(ue("Copying workspace assets..."),await ge(_,O,$)),ue("Generating application code...");const We=Qt({gsMap:R.gsMap,gsLibPath:te,env:{...R.env,BUILD_TIME:new Date}});await _.writeFile(`${N}/app.js`,We);const Ie={value:fe},Ee=await rn(`${N}/app.js`,O,te,_,S,k,$,Ie,de);fe=Ie.value;const Oe=Ee.js,ee=Ee.css;ue("Generating HTML file..."),await J.copyTextFile("public/index.html",`${O}/index.html`,ie=>nn(ie,R.title,Oe,ee||void 0));const D=[{url:`/${Oe}`,revision:null},...ee?[{url:`/${ee}`,revision:null}]:[],...se.map(ie=>({url:`/assets/icons/${ie}`,revision:null}))];if(ue("Processing service worker..."),await J.copyTextFile("public/pwa/sw.js",`${O}/sw.js`,ie=>en(ie,D)),ne)if(ue("Cleaning up temporary files..."),_.deleteDir)await _.deleteDir(N);else try{const ie=await ce(()=>import("./index-CUNXveE1.js").then(ke=>ke.T),__vite__mapDeps([0,1,2,3])),Ae=(await ce(()=>import("./index-CUNXveE1.js").then(ke=>ke.T),__vite__mapDeps([0,1,2,3]))).resolve(process.cwd(),N);await ie.rm(Ae,{recursive:!0,force:!0})}catch{}ue("Build completed!")}var Xe={exports:{}},ht;function an(){return ht||(ht=1,(function(R){(_=>{var S=Object.defineProperty,k=Object.getOwnPropertyDescriptor,F=Object.getOwnPropertyNames,$=Object.prototype.hasOwnProperty,O=(e,n)=>{for(var r in n)S(e,r,{get:n[r],enumerable:!0})},N=(e,n,r,o)=>{if(n&&typeof n=="object"||typeof n=="function")for(let m of F(n))!$.call(e,m)&&m!==r&&S(e,m,{get:()=>n[m],enumerable:!(o=k(n,m))||o.enumerable});return e},Q=e=>N(S({},"__esModule",{value:!0}),e),L=(e,n,r)=>new Promise((o,m)=>{var w=u=>{try{P(r.next(u))}catch(W){m(W)}},h=u=>{try{P(r.throw(u))}catch(W){m(W)}},P=u=>u.done?o(u.value):Promise.resolve(u.value).then(w,h);P((r=r.apply(e,n)).next())}),z={};O(z,{analyzeMetafile:()=>Rt,analyzeMetafileSync:()=>Lt,build:()=>Ct,buildSync:()=>It,context:()=>Dt,default:()=>Vt,formatMessages:()=>Ft,formatMessagesSync:()=>Ut,initialize:()=>Bt,stop:()=>Mt,transform:()=>At,transformSync:()=>Nt,version:()=>Ot}),_.exports=Q(z);function Z(e){let n=o=>{if(o===null)r.write8(0);else if(typeof o=="boolean")r.write8(1),r.write8(+o);else if(typeof o=="number")r.write8(2),r.write32(o|0);else if(typeof o=="string")r.write8(3),r.write(J(o));else if(o instanceof Uint8Array)r.write8(4),r.write(o);else if(o instanceof Array){r.write8(5),r.write32(o.length);for(let m of o)n(m)}else{let m=Object.keys(o);r.write8(6),r.write32(m.length);for(let w of m)r.write(J(w)),n(o[w])}},r=new ge;return r.write32(0),r.write32(e.id<<1|+!e.isRequest),n(e.value),ue(r.buf,r.len-4,0),r.buf.subarray(0,r.len)}function ne(e){let n=()=>{switch(r.read8()){case 0:return null;case 1:return!!r.read8();case 2:return r.read32();case 3:return te(r.read());case 4:return r.read();case 5:{let h=r.read32(),P=[];for(let u=0;u<h;u++)P.push(n());return P}case 6:{let h=r.read32(),P={};for(let u=0;u<h;u++)P[te(r.read())]=n();return P}default:throw new Error("Invalid packet")}},r=new ge(e),o=r.read32(),m=(o&1)===0;o>>>=1;let w=n();if(r.ptr!==e.length)throw new Error("Invalid packet");return{id:o,isRequest:m,value:w}}var ge=class{constructor(e=new Uint8Array(1024)){this.buf=e,this.len=0,this.ptr=0}_write(e){if(this.len+e>this.buf.length){let n=new Uint8Array((this.len+e)*2);n.set(this.buf),this.buf=n}return this.len+=e,this.len-e}write8(e){let n=this._write(1);this.buf[n]=e}write32(e){let n=this._write(4);ue(this.buf,e,n)}write(e){let n=this._write(4+e.length);ue(this.buf,e.length,n),this.buf.set(e,n+4)}_read(e){if(this.ptr+e>this.buf.length)throw new Error("Invalid packet");return this.ptr+=e,this.ptr-e}read8(){return this.buf[this._read(1)]}read32(){return de(this.buf,this._read(4))}read(){let e=this.read32(),n=new Uint8Array(e),r=this._read(n.length);return n.set(this.buf.subarray(r,r+e)),n}},J,te,fe;if(typeof TextEncoder<"u"&&typeof TextDecoder<"u"){let e=new TextEncoder,n=new TextDecoder;J=r=>e.encode(r),te=r=>n.decode(r),fe='new TextEncoder().encode("")'}else if(typeof Buffer<"u")J=e=>Buffer.from(e),te=e=>{let{buffer:n,byteOffset:r,byteLength:o}=e;return Buffer.from(n,r,o).toString()},fe='Buffer.from("")';else throw new Error("No UTF-8 codec found");if(!(J("")instanceof Uint8Array))throw new Error(`Invariant violation: "${fe} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);function de(e,n){return e[n++]|e[n++]<<8|e[n++]<<16|e[n++]<<24}function ue(e,n,r){e[r++]=n,e[r++]=n>>8,e[r++]=n>>16,e[r++]=n>>24}var se=JSON.stringify,We="warning",Ie="silent";function Ee(e,n){const r=[];for(const o of e){if(pe(o,n),o.indexOf(",")>=0)throw new Error(`Invalid ${n}: ${o}`);r.push(o)}return r.join(",")}var Oe=()=>null,ee=e=>typeof e=="boolean"?null:"a boolean",D=e=>typeof e=="string"?null:"a string",ie=e=>e instanceof RegExp?null:"a RegExp object",_e=e=>typeof e=="number"&&e===(e|0)?null:"an integer",Ae=e=>typeof e=="number"&&e===(e|0)&&e>=0&&e<=65535?null:"a valid port number",ke=e=>typeof e=="function"?null:"a function",we=e=>Array.isArray(e)?null:"an array",he=e=>Array.isArray(e)&&e.every(n=>typeof n=="string")?null:"an array of strings",ye=e=>typeof e=="object"&&e!==null&&!Array.isArray(e)?null:"an object",yt=e=>typeof e=="object"&&e!==null?null:"an array or an object",vt=e=>e instanceof WebAssembly.Module?null:"a WebAssembly.Module",tt=e=>typeof e=="object"&&!Array.isArray(e)?null:"an object or null",nt=e=>typeof e=="string"||typeof e=="boolean"?null:"a string or a boolean",bt=e=>typeof e=="string"||typeof e=="object"&&e!==null&&!Array.isArray(e)?null:"a string or an object",rt=e=>typeof e=="string"||Array.isArray(e)&&e.every(n=>typeof n=="string")?null:"a string or an array of strings",it=e=>typeof e=="string"||e instanceof Uint8Array?null:"a string or a Uint8Array",_t=e=>typeof e=="string"||e instanceof URL?null:"a string or a URL";function s(e,n,r,o){let m=e[r];if(n[r+""]=!0,m===void 0)return;let w=o(m);if(w!==null)throw new Error(`${se(r)} must be ${w}`);return m}function ae(e,n,r){for(let o in e)if(!(o in n))throw new Error(`Invalid option ${r}: ${se(o)}`)}function xt(e){let n=Object.create(null),r=s(e,n,"wasmURL",_t),o=s(e,n,"wasmModule",vt),m=s(e,n,"worker",ee);return ae(e,n,"in initialize() call"),{wasmURL:r,wasmModule:o,worker:m}}function st(e){let n;if(e!==void 0){n=Object.create(null);for(let r in e){let o=e[r];if(typeof o=="string"||o===!1)n[r]=o;else throw new Error(`Expected ${se(r)} in mangle cache to map to either a string or false`)}}return n}function Ve(e,n,r,o,m){let w=s(n,r,"color",ee),h=s(n,r,"logLevel",D),P=s(n,r,"logLimit",_e);w!==void 0?e.push(`--color=${w}`):o&&e.push("--color=true"),e.push(`--log-level=${h||m}`),e.push(`--log-limit=${P||0}`)}function pe(e,n,r){if(typeof e!="string")throw new Error(`Expected value for ${n}${r!==void 0?" "+se(r):""} to be a string, got ${typeof e} instead`);return e}function lt(e,n,r){let o=s(n,r,"legalComments",D),m=s(n,r,"sourceRoot",D),w=s(n,r,"sourcesContent",ee),h=s(n,r,"target",rt),P=s(n,r,"format",D),u=s(n,r,"globalName",D),W=s(n,r,"mangleProps",ie),V=s(n,r,"reserveProps",ie),U=s(n,r,"mangleQuoted",ee),K=s(n,r,"minify",ee),M=s(n,r,"minifySyntax",ee),H=s(n,r,"minifyWhitespace",ee),Y=s(n,r,"minifyIdentifiers",ee),A=s(n,r,"lineLimit",_e),le=s(n,r,"drop",he),j=s(n,r,"dropLabels",he),T=s(n,r,"charset",D),g=s(n,r,"treeShaking",ee),f=s(n,r,"ignoreAnnotations",ee),i=s(n,r,"jsx",D),a=s(n,r,"jsxFactory",D),d=s(n,r,"jsxFragment",D),b=s(n,r,"jsxImportSource",D),x=s(n,r,"jsxDev",ee),c=s(n,r,"jsxSideEffects",ee),p=s(n,r,"define",ye),t=s(n,r,"logOverride",ye),l=s(n,r,"supported",ye),y=s(n,r,"pure",he),v=s(n,r,"keepNames",ee),C=s(n,r,"platform",D),B=s(n,r,"tsconfigRaw",bt),re=s(n,r,"absPaths",he);if(o&&e.push(`--legal-comments=${o}`),m!==void 0&&e.push(`--source-root=${m}`),w!==void 0&&e.push(`--sources-content=${w}`),h&&e.push(`--target=${Ee(Array.isArray(h)?h:[h],"target")}`),P&&e.push(`--format=${P}`),u&&e.push(`--global-name=${u}`),C&&e.push(`--platform=${C}`),B&&e.push(`--tsconfig-raw=${typeof B=="string"?B:JSON.stringify(B)}`),K&&e.push("--minify"),M&&e.push("--minify-syntax"),H&&e.push("--minify-whitespace"),Y&&e.push("--minify-identifiers"),A&&e.push(`--line-limit=${A}`),T&&e.push(`--charset=${T}`),g!==void 0&&e.push(`--tree-shaking=${g}`),f&&e.push("--ignore-annotations"),le)for(let E of le)e.push(`--drop:${pe(E,"drop")}`);if(j&&e.push(`--drop-labels=${Ee(j,"drop label")}`),re&&e.push(`--abs-paths=${Ee(re,"abs paths")}`),W&&e.push(`--mangle-props=${Je(W)}`),V&&e.push(`--reserve-props=${Je(V)}`),U!==void 0&&e.push(`--mangle-quoted=${U}`),i&&e.push(`--jsx=${i}`),a&&e.push(`--jsx-factory=${a}`),d&&e.push(`--jsx-fragment=${d}`),b&&e.push(`--jsx-import-source=${b}`),x&&e.push("--jsx-dev"),c&&e.push("--jsx-side-effects"),p)for(let E in p){if(E.indexOf("=")>=0)throw new Error(`Invalid define: ${E}`);e.push(`--define:${E}=${pe(p[E],"define",E)}`)}if(t)for(let E in t){if(E.indexOf("=")>=0)throw new Error(`Invalid log override: ${E}`);e.push(`--log-override:${E}=${pe(t[E],"log override",E)}`)}if(l)for(let E in l){if(E.indexOf("=")>=0)throw new Error(`Invalid supported: ${E}`);const X=l[E];if(typeof X!="boolean")throw new Error(`Expected value for supported ${se(E)} to be a boolean, got ${typeof X} instead`);e.push(`--supported:${E}=${X}`)}if(y)for(let E of y)e.push(`--pure:${pe(E,"pure")}`);v&&e.push("--keep-names")}function Et(e,n,r,o,m){var w;let h=[],P=[],u=Object.create(null),W=null,V=null;Ve(h,n,u,r,o),lt(h,n,u);let U=s(n,u,"sourcemap",nt),K=s(n,u,"bundle",ee),M=s(n,u,"splitting",ee),H=s(n,u,"preserveSymlinks",ee),Y=s(n,u,"metafile",ee),A=s(n,u,"outfile",D),le=s(n,u,"outdir",D),j=s(n,u,"outbase",D),T=s(n,u,"tsconfig",D),g=s(n,u,"resolveExtensions",he),f=s(n,u,"nodePaths",he),i=s(n,u,"mainFields",he),a=s(n,u,"conditions",he),d=s(n,u,"external",he),b=s(n,u,"packages",D),x=s(n,u,"alias",ye),c=s(n,u,"loader",ye),p=s(n,u,"outExtension",ye),t=s(n,u,"publicPath",D),l=s(n,u,"entryNames",D),y=s(n,u,"chunkNames",D),v=s(n,u,"assetNames",D),C=s(n,u,"inject",he),B=s(n,u,"banner",ye),re=s(n,u,"footer",ye),E=s(n,u,"entryPoints",yt),X=s(n,u,"absWorkingDir",D),q=s(n,u,"stdin",ye),G=(w=s(n,u,"write",ee))!=null?w:m,me=s(n,u,"allowOverwrite",ee),oe=s(n,u,"mangleCache",ye);if(u.plugins=!0,ae(n,u,`in ${e}() call`),U&&h.push(`--sourcemap${U===!0?"":`=${U}`}`),K&&h.push("--bundle"),me&&h.push("--allow-overwrite"),M&&h.push("--splitting"),H&&h.push("--preserve-symlinks"),Y&&h.push("--metafile"),A&&h.push(`--outfile=${A}`),le&&h.push(`--outdir=${le}`),j&&h.push(`--outbase=${j}`),T&&h.push(`--tsconfig=${T}`),b&&h.push(`--packages=${b}`),g&&h.push(`--resolve-extensions=${Ee(g,"resolve extension")}`),t&&h.push(`--public-path=${t}`),l&&h.push(`--entry-names=${l}`),y&&h.push(`--chunk-names=${y}`),v&&h.push(`--asset-names=${v}`),i&&h.push(`--main-fields=${Ee(i,"main field")}`),a&&h.push(`--conditions=${Ee(a,"condition")}`),d)for(let I of d)h.push(`--external:${pe(I,"external")}`);if(x)for(let I in x){if(I.indexOf("=")>=0)throw new Error(`Invalid package name in alias: ${I}`);h.push(`--alias:${I}=${pe(x[I],"alias",I)}`)}if(B)for(let I in B){if(I.indexOf("=")>=0)throw new Error(`Invalid banner file type: ${I}`);h.push(`--banner:${I}=${pe(B[I],"banner",I)}`)}if(re)for(let I in re){if(I.indexOf("=")>=0)throw new Error(`Invalid footer file type: ${I}`);h.push(`--footer:${I}=${pe(re[I],"footer",I)}`)}if(C)for(let I of C)h.push(`--inject:${pe(I,"inject")}`);if(c)for(let I in c){if(I.indexOf("=")>=0)throw new Error(`Invalid loader extension: ${I}`);h.push(`--loader:${I}=${pe(c[I],"loader",I)}`)}if(p)for(let I in p){if(I.indexOf("=")>=0)throw new Error(`Invalid out extension: ${I}`);h.push(`--out-extension:${I}=${pe(p[I],"out extension",I)}`)}if(E)if(Array.isArray(E))for(let I=0,Pe=E.length;I<Pe;I++){let ve=E[I];if(typeof ve=="object"&&ve!==null){let xe=Object.create(null),Te=s(ve,xe,"in",D),be=s(ve,xe,"out",D);if(ae(ve,xe,"in entry point at index "+I),Te===void 0)throw new Error('Missing property "in" for entry point at index '+I);if(be===void 0)throw new Error('Missing property "out" for entry point at index '+I);P.push([be,Te])}else P.push(["",pe(ve,"entry point at index "+I)])}else for(let I in E)P.push([I,pe(E[I],"entry point",I)]);if(q){let I=Object.create(null),Pe=s(q,I,"contents",it),ve=s(q,I,"resolveDir",D),xe=s(q,I,"sourcefile",D),Te=s(q,I,"loader",D);ae(q,I,'in "stdin" object'),xe&&h.push(`--sourcefile=${xe}`),Te&&h.push(`--loader=${Te}`),ve&&(V=ve),typeof Pe=="string"?W=J(Pe):Pe instanceof Uint8Array&&(W=Pe)}let Se=[];if(f)for(let I of f)I+="",Se.push(I);return{entries:P,flags:h,write:G,stdinContents:W,stdinResolveDir:V,absWorkingDir:X,nodePaths:Se,mangleCache:st(oe)}}function kt(e,n,r,o){let m=[],w=Object.create(null);Ve(m,n,w,r,o),lt(m,n,w);let h=s(n,w,"sourcemap",nt),P=s(n,w,"sourcefile",D),u=s(n,w,"loader",D),W=s(n,w,"banner",D),V=s(n,w,"footer",D),U=s(n,w,"mangleCache",ye);return ae(n,w,`in ${e}() call`),h&&m.push(`--sourcemap=${h===!0?"external":h}`),P&&m.push(`--sourcefile=${P}`),u&&m.push(`--loader=${u}`),W&&m.push(`--banner=${W}`),V&&m.push(`--footer=${V}`),{flags:m,mangleCache:st(U)}}function $t(e){const n={},r={didClose:!1,reason:""};let o={},m=0,w=0,h=new Uint8Array(16*1024),P=0,u=T=>{let g=P+T.length;if(g>h.length){let i=new Uint8Array(g*2);i.set(h),h=i}h.set(T,P),P+=T.length;let f=0;for(;f+4<=P;){let i=de(h,f);if(f+4+i>P)break;f+=4,H(h.subarray(f,f+i)),f+=i}f>0&&(h.copyWithin(0,f,P),P-=f)},W=T=>{r.didClose=!0,T&&(r.reason=": "+(T.message||T));const g="The service was stopped"+r.reason;for(let f in o)o[f](g,null);o={}},V=(T,g,f)=>{if(r.didClose)return f("The service is no longer running"+r.reason,null);let i=m++;o[i]=(a,d)=>{try{f(a,d)}finally{T&&T.unref()}},T&&T.ref(),e.writeToStdin(Z({id:i,isRequest:!0,value:g}))},U=(T,g)=>{if(r.didClose)throw new Error("The service is no longer running"+r.reason);e.writeToStdin(Z({id:T,isRequest:!1,value:g}))},K=(T,g)=>L(null,null,function*(){try{if(g.command==="ping"){U(T,{});return}if(typeof g.key=="number"){const f=n[g.key];if(!f)return;const i=f[g.command];if(i){yield i(T,g);return}}throw new Error("Invalid command: "+g.command)}catch(f){const i=[Ce(f,e,null,void 0,"")];try{U(T,{errors:i})}catch{}}}),M=!0,H=T=>{if(M){M=!1;let f=String.fromCharCode(...T);if(f!=="0.25.12")throw new Error(`Cannot start service: Host version "0.25.12" does not match binary version ${se(f)}`);return}let g=ne(T);if(g.isRequest)K(g.id,g.value);else{let f=o[g.id];delete o[g.id],g.value.error?f(g.value.error,{}):f(null,g.value)}};return{readFromStdout:u,afterClose:W,service:{buildOrContext:({callName:T,refs:g,options:f,isTTY:i,defaultWD:a,callback:d})=>{let b=0;const x=w++,c={},p={ref(){++b===1&&g&&g.ref()},unref(){--b===0&&(delete n[x],g&&g.unref())}};n[x]=c,p.ref(),St(T,x,V,U,p,e,c,f,i,a,(t,l)=>{try{d(t,l)}finally{p.unref()}})},transform:({callName:T,refs:g,input:f,options:i,isTTY:a,fs:d,callback:b})=>{const x=at();let c=p=>{try{if(typeof f!="string"&&!(f instanceof Uint8Array))throw new Error('The input to "transform" must be a string or a Uint8Array');let{flags:t,mangleCache:l}=kt(T,i,a,Ie),y={command:"transform",flags:t,inputFS:p!==null,input:p!==null?J(p):typeof f=="string"?J(f):f};l&&(y.mangleCache=l),V(g,y,(v,C)=>{if(v)return b(new Error(v),null);let B=Fe(C.errors,x),re=Fe(C.warnings,x),E=1,X=()=>{if(--E===0){let q={warnings:re,code:C.code,map:C.map,mangleCache:void 0,legalComments:void 0};"legalComments"in C&&(q.legalComments=C?.legalComments),C.mangleCache&&(q.mangleCache=C?.mangleCache),b(null,q)}};if(B.length>0)return b(Ne("Transform failed",B,re),null);C.codeFS&&(E++,d.readFile(C.code,(q,G)=>{q!==null?b(q,null):(C.code=G,X())})),C.mapFS&&(E++,d.readFile(C.map,(q,G)=>{q!==null?b(q,null):(C.map=G,X())})),X()})}catch(t){let l=[];try{Ve(l,i,{},a,Ie)}catch{}const y=Ce(t,e,x,void 0,"");V(g,{command:"error",flags:l,error:y},()=>{y.detail=x.load(y.detail),b(Ne("Transform failed",[y],[]),null)})}};if((typeof f=="string"||f instanceof Uint8Array)&&f.length>1024*1024){let p=c;c=()=>d.writeFile(f,p)}c(null)},formatMessages:({callName:T,refs:g,messages:f,options:i,callback:a})=>{if(!i)throw new Error(`Missing second argument in ${T}() call`);let d={},b=s(i,d,"kind",D),x=s(i,d,"color",ee),c=s(i,d,"terminalWidth",_e);if(ae(i,d,`in ${T}() call`),b===void 0)throw new Error(`Missing "kind" in ${T}() call`);if(b!=="error"&&b!=="warning")throw new Error(`Expected "kind" to be "error" or "warning" in ${T}() call`);let p={command:"format-msgs",messages:$e(f,"messages",null,"",c),isWarning:b==="warning"};x!==void 0&&(p.color=x),c!==void 0&&(p.terminalWidth=c),V(g,p,(t,l)=>{if(t)return a(new Error(t),null);a(null,l.messages)})},analyzeMetafile:({callName:T,refs:g,metafile:f,options:i,callback:a})=>{i===void 0&&(i={});let d={},b=s(i,d,"color",ee),x=s(i,d,"verbose",ee);ae(i,d,`in ${T}() call`);let c={command:"analyze-metafile",metafile:f};b!==void 0&&(c.color=b),x!==void 0&&(c.verbose=x),V(g,c,(p,t)=>{if(p)return a(new Error(p),null);a(null,t.result)})}}}}function St(e,n,r,o,m,w,h,P,u,W,V){const U=at(),K=e==="context",M=(A,le)=>{const j=[];try{Ve(j,P,{},u,We)}catch{}const T=Ce(A,w,U,void 0,le);r(m,{command:"error",flags:j,error:T},()=>{T.detail=U.load(T.detail),V(Ne(K?"Context failed":"Build failed",[T],[]),null)})};let H;if(typeof P=="object"){const A=P.plugins;if(A!==void 0){if(!Array.isArray(A))return M(new Error('"plugins" must be an array'),"");H=A}}if(H&&H.length>0){if(w.isSync)return M(new Error("Cannot use plugins in synchronous API calls"),"");Pt(n,r,o,m,w,h,P,H,U).then(A=>{if(!A.ok)return M(A.error,A.pluginName);try{Y(A.requestPlugins,A.runOnEndCallbacks,A.scheduleOnDisposeCallbacks)}catch(le){M(le,"")}},A=>M(A,""));return}try{Y(null,(A,le)=>le([],[]),()=>{})}catch(A){M(A,"")}function Y(A,le,j){const T=w.hasFS,{entries:g,flags:f,write:i,stdinContents:a,stdinResolveDir:d,absWorkingDir:b,nodePaths:x,mangleCache:c}=Et(e,P,u,We,T);if(i&&!w.hasFS)throw new Error('The "write" option is unavailable in this environment');const p={command:"build",key:n,entries:g,flags:f,write:i,stdinContents:a,stdinResolveDir:d,absWorkingDir:b||W,nodePaths:x,context:K};A&&(p.plugins=A),c&&(p.mangleCache=c);const t=(v,C)=>{const B={errors:Fe(v.errors,U),warnings:Fe(v.warnings,U),outputFiles:void 0,metafile:void 0,mangleCache:void 0},re=B.errors.slice(),E=B.warnings.slice();v.outputFiles&&(B.outputFiles=v.outputFiles.map(jt)),v.metafile&&(B.metafile=JSON.parse(v.metafile)),v.mangleCache&&(B.mangleCache=v.mangleCache),v.writeToStdout!==void 0&&console.log(te(v.writeToStdout).replace(/\n$/,"")),le(B,(X,q)=>{if(re.length>0||X.length>0){const G=Ne("Build failed",re.concat(X),E.concat(q));return C(G,null,X,q)}C(null,B,X,q)})};let l,y;K&&(h["on-end"]=(v,C)=>new Promise(B=>{t(C,(re,E,X,q)=>{const G={errors:X,warnings:q};y&&y(re,E),l=void 0,y=void 0,o(v,G),B()})})),r(m,p,(v,C)=>{if(v)return V(new Error(v),null);if(!K)return t(C,(E,X)=>(j(),V(E,X)));if(C.errors.length>0)return V(Ne("Context failed",C.errors,C.warnings),null);let B=!1;const re={rebuild:()=>(l||(l=new Promise((E,X)=>{let q;y=(me,oe)=>{q||(q=()=>me?X(me):E(oe))};const G=()=>{r(m,{command:"rebuild",key:n},(oe,Se)=>{oe?X(new Error(oe)):q?q():G()})};G()})),l),watch:(E={})=>new Promise((X,q)=>{if(!w.hasFS)throw new Error('Cannot use the "watch" API in this environment');const G={},me=s(E,G,"delay",_e);ae(E,G,"in watch() call");const oe={command:"watch",key:n};me&&(oe.delay=me),r(m,oe,Se=>{Se?q(new Error(Se)):X(void 0)})}),serve:(E={})=>new Promise((X,q)=>{if(!w.hasFS)throw new Error('Cannot use the "serve" API in this environment');const G={},me=s(E,G,"port",Ae),oe=s(E,G,"host",D),Se=s(E,G,"servedir",D),I=s(E,G,"keyfile",D),Pe=s(E,G,"certfile",D),ve=s(E,G,"fallback",D),xe=s(E,G,"cors",ye),Te=s(E,G,"onRequest",ke);ae(E,G,"in serve() call");const be={command:"serve",key:n,onRequest:!!Te};if(me!==void 0&&(be.port=me),oe!==void 0&&(be.host=oe),Se!==void 0&&(be.servedir=Se),I!==void 0&&(be.keyfile=I),Pe!==void 0&&(be.certfile=Pe),ve!==void 0&&(be.fallback=ve),xe){const Le={},Re=s(xe,Le,"origin",rt);ae(xe,Le,'on "cors" object'),Array.isArray(Re)?be.corsOrigin=Re:Re!==void 0&&(be.corsOrigin=[Re])}r(m,be,(Le,Re)=>{if(Le)return q(new Error(Le));Te&&(h["serve-request"]=(zt,Gt)=>{Te(Gt.args),o(zt,{})}),X(Re)})}),cancel:()=>new Promise(E=>{if(B)return E();r(m,{command:"cancel",key:n},()=>{E()})}),dispose:()=>new Promise(E=>{if(B)return E();B=!0,r(m,{command:"dispose",key:n},()=>{E(),j(),m.unref()})})};m.ref(),V(null,re)})}}var Pt=(e,n,r,o,m,w,h,P,u)=>L(null,null,function*(){let W=[],V=[],U={},K={},M=[],H=0,Y=0,A=[],le=!1;P=[...P];for(let g of P){let f={};if(typeof g!="object")throw new Error(`Plugin at index ${Y} must be an object`);const i=s(g,f,"name",D);if(typeof i!="string"||i==="")throw new Error(`Plugin at index ${Y} is missing a name`);try{let a=s(g,f,"setup",ke);if(typeof a!="function")throw new Error("Plugin is missing a setup function");ae(g,f,`on plugin ${se(i)}`);let d={name:i,onStart:!1,onEnd:!1,onResolve:[],onLoad:[]};Y++;let x=a({initialOptions:h,resolve:(c,p={})=>{if(!le)throw new Error('Cannot call "resolve" before plugin setup has completed');if(typeof c!="string")throw new Error("The path to resolve must be a string");let t=Object.create(null),l=s(p,t,"pluginName",D),y=s(p,t,"importer",D),v=s(p,t,"namespace",D),C=s(p,t,"resolveDir",D),B=s(p,t,"kind",D),re=s(p,t,"pluginData",Oe),E=s(p,t,"with",ye);return ae(p,t,"in resolve() call"),new Promise((X,q)=>{const G={command:"resolve",path:c,key:e,pluginName:i};if(l!=null&&(G.pluginName=l),y!=null&&(G.importer=y),v!=null&&(G.namespace=v),C!=null&&(G.resolveDir=C),B!=null)G.kind=B;else throw new Error('Must specify "kind" when calling "resolve"');re!=null&&(G.pluginData=u.store(re)),E!=null&&(G.with=Tt(E,"with")),n(o,G,(me,oe)=>{me!==null?q(new Error(me)):X({errors:Fe(oe.errors,u),warnings:Fe(oe.warnings,u),path:oe.path,external:oe.external,sideEffects:oe.sideEffects,namespace:oe.namespace,suffix:oe.suffix,pluginData:u.load(oe.pluginData)})})})},onStart(c){let p='This error came from the "onStart" callback registered here:',t=ze(new Error(p),m,"onStart");W.push({name:i,callback:c,note:t}),d.onStart=!0},onEnd(c){let p='This error came from the "onEnd" callback registered here:',t=ze(new Error(p),m,"onEnd");V.push({name:i,callback:c,note:t}),d.onEnd=!0},onResolve(c,p){let t='This error came from the "onResolve" callback registered here:',l=ze(new Error(t),m,"onResolve"),y={},v=s(c,y,"filter",ie),C=s(c,y,"namespace",D);if(ae(c,y,`in onResolve() call for plugin ${se(i)}`),v==null)throw new Error("onResolve() call is missing a filter");let B=H++;U[B]={name:i,callback:p,note:l},d.onResolve.push({id:B,filter:Je(v),namespace:C||""})},onLoad(c,p){let t='This error came from the "onLoad" callback registered here:',l=ze(new Error(t),m,"onLoad"),y={},v=s(c,y,"filter",ie),C=s(c,y,"namespace",D);if(ae(c,y,`in onLoad() call for plugin ${se(i)}`),v==null)throw new Error("onLoad() call is missing a filter");let B=H++;K[B]={name:i,callback:p,note:l},d.onLoad.push({id:B,filter:Je(v),namespace:C||""})},onDispose(c){M.push(c)},esbuild:m.esbuild});x&&(yield x),A.push(d)}catch(a){return{ok:!1,error:a,pluginName:i}}}w["on-start"]=(g,f)=>L(null,null,function*(){u.clear();let i={errors:[],warnings:[]};yield Promise.all(W.map(a=>L(null,[a],function*({name:d,callback:b,note:x}){try{let c=yield b();if(c!=null){if(typeof c!="object")throw new Error(`Expected onStart() callback in plugin ${se(d)} to return an object`);let p={},t=s(c,p,"errors",we),l=s(c,p,"warnings",we);ae(c,p,`from onStart() callback in plugin ${se(d)}`),t!=null&&i.errors.push(...$e(t,"errors",u,d,void 0)),l!=null&&i.warnings.push(...$e(l,"warnings",u,d,void 0))}}catch(c){i.errors.push(Ce(c,m,u,x&&x(),d))}}))),r(g,i)}),w["on-resolve"]=(g,f)=>L(null,null,function*(){let i={},a="",d,b;for(let x of f.ids)try{({name:a,callback:d,note:b}=U[x]);let c=yield d({path:f.path,importer:f.importer,namespace:f.namespace,resolveDir:f.resolveDir,kind:f.kind,pluginData:u.load(f.pluginData),with:f.with});if(c!=null){if(typeof c!="object")throw new Error(`Expected onResolve() callback in plugin ${se(a)} to return an object`);let p={},t=s(c,p,"pluginName",D),l=s(c,p,"path",D),y=s(c,p,"namespace",D),v=s(c,p,"suffix",D),C=s(c,p,"external",ee),B=s(c,p,"sideEffects",ee),re=s(c,p,"pluginData",Oe),E=s(c,p,"errors",we),X=s(c,p,"warnings",we),q=s(c,p,"watchFiles",he),G=s(c,p,"watchDirs",he);ae(c,p,`from onResolve() callback in plugin ${se(a)}`),i.id=x,t!=null&&(i.pluginName=t),l!=null&&(i.path=l),y!=null&&(i.namespace=y),v!=null&&(i.suffix=v),C!=null&&(i.external=C),B!=null&&(i.sideEffects=B),re!=null&&(i.pluginData=u.store(re)),E!=null&&(i.errors=$e(E,"errors",u,a,void 0)),X!=null&&(i.warnings=$e(X,"warnings",u,a,void 0)),q!=null&&(i.watchFiles=Ge(q,"watchFiles")),G!=null&&(i.watchDirs=Ge(G,"watchDirs"));break}}catch(c){i={id:x,errors:[Ce(c,m,u,b&&b(),a)]};break}r(g,i)}),w["on-load"]=(g,f)=>L(null,null,function*(){let i={},a="",d,b;for(let x of f.ids)try{({name:a,callback:d,note:b}=K[x]);let c=yield d({path:f.path,namespace:f.namespace,suffix:f.suffix,pluginData:u.load(f.pluginData),with:f.with});if(c!=null){if(typeof c!="object")throw new Error(`Expected onLoad() callback in plugin ${se(a)} to return an object`);let p={},t=s(c,p,"pluginName",D),l=s(c,p,"contents",it),y=s(c,p,"resolveDir",D),v=s(c,p,"pluginData",Oe),C=s(c,p,"loader",D),B=s(c,p,"errors",we),re=s(c,p,"warnings",we),E=s(c,p,"watchFiles",he),X=s(c,p,"watchDirs",he);ae(c,p,`from onLoad() callback in plugin ${se(a)}`),i.id=x,t!=null&&(i.pluginName=t),l instanceof Uint8Array?i.contents=l:l!=null&&(i.contents=J(l)),y!=null&&(i.resolveDir=y),v!=null&&(i.pluginData=u.store(v)),C!=null&&(i.loader=C),B!=null&&(i.errors=$e(B,"errors",u,a,void 0)),re!=null&&(i.warnings=$e(re,"warnings",u,a,void 0)),E!=null&&(i.watchFiles=Ge(E,"watchFiles")),X!=null&&(i.watchDirs=Ge(X,"watchDirs"));break}}catch(c){i={id:x,errors:[Ce(c,m,u,b&&b(),a)]};break}r(g,i)});let j=(g,f)=>f([],[]);V.length>0&&(j=(g,f)=>{L(null,null,function*(){const i=[],a=[];for(const{name:d,callback:b,note:x}of V){let c,p;try{const t=yield b(g);if(t!=null){if(typeof t!="object")throw new Error(`Expected onEnd() callback in plugin ${se(d)} to return an object`);let l={},y=s(t,l,"errors",we),v=s(t,l,"warnings",we);ae(t,l,`from onEnd() callback in plugin ${se(d)}`),y!=null&&(c=$e(y,"errors",u,d,void 0)),v!=null&&(p=$e(v,"warnings",u,d,void 0))}}catch(t){c=[Ce(t,m,u,x&&x(),d)]}if(c){i.push(...c);try{g.errors.push(...c)}catch{}}if(p){a.push(...p);try{g.warnings.push(...p)}catch{}}}f(i,a)})});let T=()=>{for(const g of M)setTimeout(()=>g(),0)};return le=!0,{ok:!0,requestPlugins:A,runOnEndCallbacks:j,scheduleOnDisposeCallbacks:T}});function at(){const e=new Map;let n=0;return{clear(){e.clear()},load(r){return e.get(r)},store(r){if(r===void 0)return-1;const o=n++;return e.set(o,r),o}}}function ze(e,n,r){let o,m=!1;return()=>{if(m)return o;m=!0;try{let w=(e.stack+"").split(`
`);w.splice(1,1);let h=ot(n,w,r);if(h)return o={text:e.message,location:h},o}catch{}}}function Ce(e,n,r,o,m){let w="Internal error",h=null;try{w=(e&&e.message||e)+""}catch{}try{h=ot(n,(e.stack+"").split(`
`),"")}catch{}return{id:"",pluginName:m,text:w,location:h,notes:o?[o]:[],detail:r?r.store(e):-1}}function ot(e,n,r){let o="    at ";if(e.readFileSync&&!n[0].startsWith(o)&&n[1].startsWith(o))for(let m=1;m<n.length;m++){let w=n[m];if(w.startsWith(o))for(w=w.slice(o.length);;){let h=/^(?:new |async )?\S+ \((.*)\)$/.exec(w);if(h){w=h[1];continue}if(h=/^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(w),h){w=h[1];continue}if(h=/^(\S+):(\d+):(\d+)$/.exec(w),h){let P;try{P=e.readFileSync(h[1],"utf8")}catch{break}let u=P.split(/\r\n|\r|\n|\u2028|\u2029/)[+h[2]-1]||"",W=+h[3]-1,V=u.slice(W,W+r.length)===r?r.length:0;return{file:h[1],namespace:"file",line:+h[2],column:J(u.slice(0,W)).length,length:J(u.slice(W,W+V)).length,lineText:u+`
`+n.slice(1).join(`
`),suggestion:""}}break}}return null}function Ne(e,n,r){let o=5;e+=n.length<1?"":` with ${n.length} error${n.length<2?"":"s"}:`+n.slice(0,o+1).map((w,h)=>{if(h===o)return`
...`;if(!w.location)return`
error: ${w.text}`;let{file:P,line:u,column:W}=w.location,V=w.pluginName?`[plugin: ${w.pluginName}] `:"";return`
${P}:${u}:${W}: ERROR: ${V}${w.text}`}).join("");let m=new Error(e);for(const[w,h]of[["errors",n],["warnings",r]])Object.defineProperty(m,w,{configurable:!0,enumerable:!0,get:()=>h,set:P=>Object.defineProperty(m,w,{configurable:!0,enumerable:!0,value:P})});return m}function Fe(e,n){for(const r of e)r.detail=n.load(r.detail);return e}function ct(e,n,r){if(e==null)return null;let o={},m=s(e,o,"file",D),w=s(e,o,"namespace",D),h=s(e,o,"line",_e),P=s(e,o,"column",_e),u=s(e,o,"length",_e),W=s(e,o,"lineText",D),V=s(e,o,"suggestion",D);if(ae(e,o,n),W){const U=W.slice(0,(P&&P>0?P:0)+(u&&u>0?u:0)+(r&&r>0?r:80));!/[\x7F-\uFFFF]/.test(U)&&!/\n/.test(W)&&(W=U)}return{file:m||"",namespace:w||"",line:h||0,column:P||0,length:u||0,lineText:W||"",suggestion:V||""}}function $e(e,n,r,o,m){let w=[],h=0;for(const P of e){let u={},W=s(P,u,"id",D),V=s(P,u,"pluginName",D),U=s(P,u,"text",D),K=s(P,u,"location",tt),M=s(P,u,"notes",we),H=s(P,u,"detail",Oe),Y=`in element ${h} of "${n}"`;ae(P,u,Y);let A=[];if(M)for(const le of M){let j={},T=s(le,j,"text",D),g=s(le,j,"location",tt);ae(le,j,Y),A.push({text:T||"",location:ct(g,Y,m)})}w.push({id:W||"",pluginName:V||o,text:U||"",location:ct(K,Y,m),notes:A,detail:r?r.store(H):-1}),h++}return w}function Ge(e,n){const r=[];for(const o of e){if(typeof o!="string")throw new Error(`${se(n)} must be an array of strings`);r.push(o)}return r}function Tt(e,n){const r=Object.create(null);for(const o in e){const m=e[o];if(typeof m!="string")throw new Error(`key ${se(o)} in object ${se(n)} must be a string`);r[o]=m}return r}function jt({path:e,contents:n,hash:r}){let o=null;return{path:e,contents:n,hash:r,get text(){const m=this.contents;return(o===null||m!==n)&&(n=m,o=te(m)),o}}}function Je(e){let n=e.source;return e.flags&&(n=`(?${e.flags})${n}`),n}var Ot="0.25.12",Ct=e=>Ue().build(e),Dt=e=>Ue().context(e),At=(e,n)=>Ue().transform(e,n),Ft=(e,n)=>Ue().formatMessages(e,n),Rt=(e,n)=>Ue().analyzeMetafile(e,n),It=()=>{throw new Error('The "buildSync" API only works in node')},Nt=()=>{throw new Error('The "transformSync" API only works in node')},Ut=()=>{throw new Error('The "formatMessagesSync" API only works in node')},Lt=()=>{throw new Error('The "analyzeMetafileSync" API only works in node')},Mt=()=>(qe&&qe(),Promise.resolve()),De,qe,He,Ue=()=>{if(He)return He;throw De?new Error('You need to wait for the promise returned from "initialize" to be resolved before calling this'):new Error('You need to call "initialize" before calling this')},Bt=e=>{e=xt(e||{});let n=e.wasmURL,r=e.wasmModule,o=e.worker!==!1;if(!n&&!r)throw new Error('Must provide either the "wasmURL" option or the "wasmModule" option');if(De)throw new Error('Cannot call "initialize" more than once');return De=Wt(n||"",r,o),De.catch(()=>{De=void 0}),De},Wt=(e,n,r)=>L(null,null,function*(){let o,m;const w=new Promise(U=>m=U);if(r){let U=new Blob([`onmessage=((postMessage) => {
      // Copyright 2018 The Go Authors. All rights reserved.
      // Use of this source code is governed by a BSD-style
      // license that can be found in the LICENSE file.
      var __async = (__this, __arguments, generator) => {
        return new Promise((resolve, reject) => {
          var fulfilled = (value) => {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          };
          var rejected = (value) => {
            try {
              step(generator.throw(value));
            } catch (e) {
              reject(e);
            }
          };
          var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
          step((generator = generator.apply(__this, __arguments)).next());
        });
      };
      let onmessage;
      let globalThis = {};
      for (let o = self; o; o = Object.getPrototypeOf(o))
        for (let k of Object.getOwnPropertyNames(o))
          if (!(k in globalThis))
            Object.defineProperty(globalThis, k, { get: () => self[k] });
      "use strict";
      (() => {
        const enosys = () => {
          const err = new Error("not implemented");
          err.code = "ENOSYS";
          return err;
        };
        if (!globalThis.fs) {
          let outputBuf = "";
          globalThis.fs = {
            constants: { O_WRONLY: -1, O_RDWR: -1, O_CREAT: -1, O_TRUNC: -1, O_APPEND: -1, O_EXCL: -1 },
            // unused
            writeSync(fd, buf) {
              outputBuf += decoder.decode(buf);
              const nl = outputBuf.lastIndexOf("\\n");
              if (nl != -1) {
                console.log(outputBuf.substring(0, nl));
                outputBuf = outputBuf.substring(nl + 1);
              }
              return buf.length;
            },
            write(fd, buf, offset, length, position, callback) {
              if (offset !== 0 || length !== buf.length || position !== null) {
                callback(enosys());
                return;
              }
              const n = this.writeSync(fd, buf);
              callback(null, n);
            },
            chmod(path, mode, callback) {
              callback(enosys());
            },
            chown(path, uid, gid, callback) {
              callback(enosys());
            },
            close(fd, callback) {
              callback(enosys());
            },
            fchmod(fd, mode, callback) {
              callback(enosys());
            },
            fchown(fd, uid, gid, callback) {
              callback(enosys());
            },
            fstat(fd, callback) {
              callback(enosys());
            },
            fsync(fd, callback) {
              callback(null);
            },
            ftruncate(fd, length, callback) {
              callback(enosys());
            },
            lchown(path, uid, gid, callback) {
              callback(enosys());
            },
            link(path, link, callback) {
              callback(enosys());
            },
            lstat(path, callback) {
              callback(enosys());
            },
            mkdir(path, perm, callback) {
              callback(enosys());
            },
            open(path, flags, mode, callback) {
              callback(enosys());
            },
            read(fd, buffer, offset, length, position, callback) {
              callback(enosys());
            },
            readdir(path, callback) {
              callback(enosys());
            },
            readlink(path, callback) {
              callback(enosys());
            },
            rename(from, to, callback) {
              callback(enosys());
            },
            rmdir(path, callback) {
              callback(enosys());
            },
            stat(path, callback) {
              callback(enosys());
            },
            symlink(path, link, callback) {
              callback(enosys());
            },
            truncate(path, length, callback) {
              callback(enosys());
            },
            unlink(path, callback) {
              callback(enosys());
            },
            utimes(path, atime, mtime, callback) {
              callback(enosys());
            }
          };
        }
        if (!globalThis.process) {
          globalThis.process = {
            getuid() {
              return -1;
            },
            getgid() {
              return -1;
            },
            geteuid() {
              return -1;
            },
            getegid() {
              return -1;
            },
            getgroups() {
              throw enosys();
            },
            pid: -1,
            ppid: -1,
            umask() {
              throw enosys();
            },
            cwd() {
              throw enosys();
            },
            chdir() {
              throw enosys();
            }
          };
        }
        if (!globalThis.crypto) {
          throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");
        }
        if (!globalThis.performance) {
          throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");
        }
        if (!globalThis.TextEncoder) {
          throw new Error("globalThis.TextEncoder is not available, polyfill required");
        }
        if (!globalThis.TextDecoder) {
          throw new Error("globalThis.TextDecoder is not available, polyfill required");
        }
        const encoder = new TextEncoder("utf-8");
        const decoder = new TextDecoder("utf-8");
        globalThis.Go = class {
          constructor() {
            this.argv = ["js"];
            this.env = {};
            this.exit = (code) => {
              if (code !== 0) {
                console.warn("exit code:", code);
              }
            };
            this._exitPromise = new Promise((resolve) => {
              this._resolveExitPromise = resolve;
            });
            this._pendingEvent = null;
            this._scheduledTimeouts = /* @__PURE__ */ new Map();
            this._nextCallbackTimeoutID = 1;
            const setInt64 = (addr, v) => {
              this.mem.setUint32(addr + 0, v, true);
              this.mem.setUint32(addr + 4, Math.floor(v / 4294967296), true);
            };
            const setInt32 = (addr, v) => {
              this.mem.setUint32(addr + 0, v, true);
            };
            const getInt64 = (addr) => {
              const low = this.mem.getUint32(addr + 0, true);
              const high = this.mem.getInt32(addr + 4, true);
              return low + high * 4294967296;
            };
            const loadValue = (addr) => {
              const f = this.mem.getFloat64(addr, true);
              if (f === 0) {
                return void 0;
              }
              if (!isNaN(f)) {
                return f;
              }
              const id = this.mem.getUint32(addr, true);
              return this._values[id];
            };
            const storeValue = (addr, v) => {
              const nanHead = 2146959360;
              if (typeof v === "number" && v !== 0) {
                if (isNaN(v)) {
                  this.mem.setUint32(addr + 4, nanHead, true);
                  this.mem.setUint32(addr, 0, true);
                  return;
                }
                this.mem.setFloat64(addr, v, true);
                return;
              }
              if (v === void 0) {
                this.mem.setFloat64(addr, 0, true);
                return;
              }
              let id = this._ids.get(v);
              if (id === void 0) {
                id = this._idPool.pop();
                if (id === void 0) {
                  id = this._values.length;
                }
                this._values[id] = v;
                this._goRefCounts[id] = 0;
                this._ids.set(v, id);
              }
              this._goRefCounts[id]++;
              let typeFlag = 0;
              switch (typeof v) {
                case "object":
                  if (v !== null) {
                    typeFlag = 1;
                  }
                  break;
                case "string":
                  typeFlag = 2;
                  break;
                case "symbol":
                  typeFlag = 3;
                  break;
                case "function":
                  typeFlag = 4;
                  break;
              }
              this.mem.setUint32(addr + 4, nanHead | typeFlag, true);
              this.mem.setUint32(addr, id, true);
            };
            const loadSlice = (addr) => {
              const array = getInt64(addr + 0);
              const len = getInt64(addr + 8);
              return new Uint8Array(this._inst.exports.mem.buffer, array, len);
            };
            const loadSliceOfValues = (addr) => {
              const array = getInt64(addr + 0);
              const len = getInt64(addr + 8);
              const a = new Array(len);
              for (let i = 0; i < len; i++) {
                a[i] = loadValue(array + i * 8);
              }
              return a;
            };
            const loadString = (addr) => {
              const saddr = getInt64(addr + 0);
              const len = getInt64(addr + 8);
              return decoder.decode(new DataView(this._inst.exports.mem.buffer, saddr, len));
            };
            const timeOrigin = Date.now() - performance.now();
            this.importObject = {
              _gotest: {
                add: (a, b) => a + b
              },
              gojs: {
                // Go's SP does not change as long as no Go code is running. Some operations (e.g. calls, getters and setters)
                // may synchronously trigger a Go event handler. This makes Go code get executed in the middle of the imported
                // function. A goroutine can switch to a new stack if the current stack is too small (see morestack function).
                // This changes the SP, thus we have to update the SP used by the imported function.
                // func wasmExit(code int32)
                "runtime.wasmExit": (sp) => {
                  sp >>>= 0;
                  const code = this.mem.getInt32(sp + 8, true);
                  this.exited = true;
                  delete this._inst;
                  delete this._values;
                  delete this._goRefCounts;
                  delete this._ids;
                  delete this._idPool;
                  this.exit(code);
                },
                // func wasmWrite(fd uintptr, p unsafe.Pointer, n int32)
                "runtime.wasmWrite": (sp) => {
                  sp >>>= 0;
                  const fd = getInt64(sp + 8);
                  const p = getInt64(sp + 16);
                  const n = this.mem.getInt32(sp + 24, true);
                  globalThis.fs.writeSync(fd, new Uint8Array(this._inst.exports.mem.buffer, p, n));
                },
                // func resetMemoryDataView()
                "runtime.resetMemoryDataView": (sp) => {
                  sp >>>= 0;
                  this.mem = new DataView(this._inst.exports.mem.buffer);
                },
                // func nanotime1() int64
                "runtime.nanotime1": (sp) => {
                  sp >>>= 0;
                  setInt64(sp + 8, (timeOrigin + performance.now()) * 1e6);
                },
                // func walltime() (sec int64, nsec int32)
                "runtime.walltime": (sp) => {
                  sp >>>= 0;
                  const msec = (/* @__PURE__ */ new Date()).getTime();
                  setInt64(sp + 8, msec / 1e3);
                  this.mem.setInt32(sp + 16, msec % 1e3 * 1e6, true);
                },
                // func scheduleTimeoutEvent(delay int64) int32
                "runtime.scheduleTimeoutEvent": (sp) => {
                  sp >>>= 0;
                  const id = this._nextCallbackTimeoutID;
                  this._nextCallbackTimeoutID++;
                  this._scheduledTimeouts.set(id, setTimeout(
                    () => {
                      this._resume();
                      while (this._scheduledTimeouts.has(id)) {
                        console.warn("scheduleTimeoutEvent: missed timeout event");
                        this._resume();
                      }
                    },
                    getInt64(sp + 8)
                  ));
                  this.mem.setInt32(sp + 16, id, true);
                },
                // func clearTimeoutEvent(id int32)
                "runtime.clearTimeoutEvent": (sp) => {
                  sp >>>= 0;
                  const id = this.mem.getInt32(sp + 8, true);
                  clearTimeout(this._scheduledTimeouts.get(id));
                  this._scheduledTimeouts.delete(id);
                },
                // func getRandomData(r []byte)
                "runtime.getRandomData": (sp) => {
                  sp >>>= 0;
                  crypto.getRandomValues(loadSlice(sp + 8));
                },
                // func finalizeRef(v ref)
                "syscall/js.finalizeRef": (sp) => {
                  sp >>>= 0;
                  const id = this.mem.getUint32(sp + 8, true);
                  this._goRefCounts[id]--;
                  if (this._goRefCounts[id] === 0) {
                    const v = this._values[id];
                    this._values[id] = null;
                    this._ids.delete(v);
                    this._idPool.push(id);
                  }
                },
                // func stringVal(value string) ref
                "syscall/js.stringVal": (sp) => {
                  sp >>>= 0;
                  storeValue(sp + 24, loadString(sp + 8));
                },
                // func valueGet(v ref, p string) ref
                "syscall/js.valueGet": (sp) => {
                  sp >>>= 0;
                  const result = Reflect.get(loadValue(sp + 8), loadString(sp + 16));
                  sp = this._inst.exports.getsp() >>> 0;
                  storeValue(sp + 32, result);
                },
                // func valueSet(v ref, p string, x ref)
                "syscall/js.valueSet": (sp) => {
                  sp >>>= 0;
                  Reflect.set(loadValue(sp + 8), loadString(sp + 16), loadValue(sp + 32));
                },
                // func valueDelete(v ref, p string)
                "syscall/js.valueDelete": (sp) => {
                  sp >>>= 0;
                  Reflect.deleteProperty(loadValue(sp + 8), loadString(sp + 16));
                },
                // func valueIndex(v ref, i int) ref
                "syscall/js.valueIndex": (sp) => {
                  sp >>>= 0;
                  storeValue(sp + 24, Reflect.get(loadValue(sp + 8), getInt64(sp + 16)));
                },
                // valueSetIndex(v ref, i int, x ref)
                "syscall/js.valueSetIndex": (sp) => {
                  sp >>>= 0;
                  Reflect.set(loadValue(sp + 8), getInt64(sp + 16), loadValue(sp + 24));
                },
                // func valueCall(v ref, m string, args []ref) (ref, bool)
                "syscall/js.valueCall": (sp) => {
                  sp >>>= 0;
                  try {
                    const v = loadValue(sp + 8);
                    const m = Reflect.get(v, loadString(sp + 16));
                    const args = loadSliceOfValues(sp + 32);
                    const result = Reflect.apply(m, v, args);
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 56, result);
                    this.mem.setUint8(sp + 64, 1);
                  } catch (err) {
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 56, err);
                    this.mem.setUint8(sp + 64, 0);
                  }
                },
                // func valueInvoke(v ref, args []ref) (ref, bool)
                "syscall/js.valueInvoke": (sp) => {
                  sp >>>= 0;
                  try {
                    const v = loadValue(sp + 8);
                    const args = loadSliceOfValues(sp + 16);
                    const result = Reflect.apply(v, void 0, args);
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, result);
                    this.mem.setUint8(sp + 48, 1);
                  } catch (err) {
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, err);
                    this.mem.setUint8(sp + 48, 0);
                  }
                },
                // func valueNew(v ref, args []ref) (ref, bool)
                "syscall/js.valueNew": (sp) => {
                  sp >>>= 0;
                  try {
                    const v = loadValue(sp + 8);
                    const args = loadSliceOfValues(sp + 16);
                    const result = Reflect.construct(v, args);
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, result);
                    this.mem.setUint8(sp + 48, 1);
                  } catch (err) {
                    sp = this._inst.exports.getsp() >>> 0;
                    storeValue(sp + 40, err);
                    this.mem.setUint8(sp + 48, 0);
                  }
                },
                // func valueLength(v ref) int
                "syscall/js.valueLength": (sp) => {
                  sp >>>= 0;
                  setInt64(sp + 16, parseInt(loadValue(sp + 8).length));
                },
                // valuePrepareString(v ref) (ref, int)
                "syscall/js.valuePrepareString": (sp) => {
                  sp >>>= 0;
                  const str = encoder.encode(String(loadValue(sp + 8)));
                  storeValue(sp + 16, str);
                  setInt64(sp + 24, str.length);
                },
                // valueLoadString(v ref, b []byte)
                "syscall/js.valueLoadString": (sp) => {
                  sp >>>= 0;
                  const str = loadValue(sp + 8);
                  loadSlice(sp + 16).set(str);
                },
                // func valueInstanceOf(v ref, t ref) bool
                "syscall/js.valueInstanceOf": (sp) => {
                  sp >>>= 0;
                  this.mem.setUint8(sp + 24, loadValue(sp + 8) instanceof loadValue(sp + 16) ? 1 : 0);
                },
                // func copyBytesToGo(dst []byte, src ref) (int, bool)
                "syscall/js.copyBytesToGo": (sp) => {
                  sp >>>= 0;
                  const dst = loadSlice(sp + 8);
                  const src = loadValue(sp + 32);
                  if (!(src instanceof Uint8Array || src instanceof Uint8ClampedArray)) {
                    this.mem.setUint8(sp + 48, 0);
                    return;
                  }
                  const toCopy = src.subarray(0, dst.length);
                  dst.set(toCopy);
                  setInt64(sp + 40, toCopy.length);
                  this.mem.setUint8(sp + 48, 1);
                },
                // func copyBytesToJS(dst ref, src []byte) (int, bool)
                "syscall/js.copyBytesToJS": (sp) => {
                  sp >>>= 0;
                  const dst = loadValue(sp + 8);
                  const src = loadSlice(sp + 16);
                  if (!(dst instanceof Uint8Array || dst instanceof Uint8ClampedArray)) {
                    this.mem.setUint8(sp + 48, 0);
                    return;
                  }
                  const toCopy = src.subarray(0, dst.length);
                  dst.set(toCopy);
                  setInt64(sp + 40, toCopy.length);
                  this.mem.setUint8(sp + 48, 1);
                },
                "debug": (value) => {
                  console.log(value);
                }
              }
            };
          }
          run(instance) {
            return __async(this, null, function* () {
              if (!(instance instanceof WebAssembly.Instance)) {
                throw new Error("Go.run: WebAssembly.Instance expected");
              }
              this._inst = instance;
              this.mem = new DataView(this._inst.exports.mem.buffer);
              this._values = [
                // JS values that Go currently has references to, indexed by reference id
                NaN,
                0,
                null,
                true,
                false,
                globalThis,
                this
              ];
              this._goRefCounts = new Array(this._values.length).fill(Infinity);
              this._ids = /* @__PURE__ */ new Map([
                // mapping from JS values to reference ids
                [0, 1],
                [null, 2],
                [true, 3],
                [false, 4],
                [globalThis, 5],
                [this, 6]
              ]);
              this._idPool = [];
              this.exited = false;
              let offset = 4096;
              const strPtr = (str) => {
                const ptr = offset;
                const bytes = encoder.encode(str + "\\0");
                new Uint8Array(this.mem.buffer, offset, bytes.length).set(bytes);
                offset += bytes.length;
                if (offset % 8 !== 0) {
                  offset += 8 - offset % 8;
                }
                return ptr;
              };
              const argc = this.argv.length;
              const argvPtrs = [];
              this.argv.forEach((arg) => {
                argvPtrs.push(strPtr(arg));
              });
              argvPtrs.push(0);
              const keys = Object.keys(this.env).sort();
              keys.forEach((key) => {
                argvPtrs.push(strPtr(\`\${key}=\${this.env[key]}\`));
              });
              argvPtrs.push(0);
              const argv = offset;
              argvPtrs.forEach((ptr) => {
                this.mem.setUint32(offset, ptr, true);
                this.mem.setUint32(offset + 4, 0, true);
                offset += 8;
              });
              const wasmMinDataAddr = 4096 + 8192;
              if (offset >= wasmMinDataAddr) {
                throw new Error("total length of command line and environment variables exceeds limit");
              }
              this._inst.exports.run(argc, argv);
              if (this.exited) {
                this._resolveExitPromise();
              }
              yield this._exitPromise;
            });
          }
          _resume() {
            if (this.exited) {
              throw new Error("Go program has already exited");
            }
            this._inst.exports.resume();
            if (this.exited) {
              this._resolveExitPromise();
            }
          }
          _makeFuncWrapper(id) {
            const go = this;
            return function() {
              const event = { id, this: this, args: arguments };
              go._pendingEvent = event;
              go._resume();
              return event.result;
            };
          }
        };
      })();
      onmessage = ({ data: wasm }) => {
        let decoder = new TextDecoder();
        let fs = globalThis.fs;
        let stderr = "";
        fs.writeSync = (fd, buffer) => {
          if (fd === 1) {
            postMessage(buffer);
          } else if (fd === 2) {
            stderr += decoder.decode(buffer);
            let parts = stderr.split("\\n");
            if (parts.length > 1) console.log(parts.slice(0, -1).join("\\n"));
            stderr = parts[parts.length - 1];
          } else {
            throw new Error("Bad write");
          }
          return buffer.length;
        };
        let stdin = [];
        let resumeStdin;
        let stdinPos = 0;
        onmessage = ({ data }) => {
          if (data.length > 0) {
            stdin.push(data);
            if (resumeStdin) resumeStdin();
          }
          return go;
        };
        fs.read = (fd, buffer, offset, length, position, callback) => {
          if (fd !== 0 || offset !== 0 || length !== buffer.length || position !== null) {
            throw new Error("Bad read");
          }
          if (stdin.length === 0) {
            resumeStdin = () => fs.read(fd, buffer, offset, length, position, callback);
            return;
          }
          let first = stdin[0];
          let count = Math.max(0, Math.min(length, first.length - stdinPos));
          buffer.set(first.subarray(stdinPos, stdinPos + count), offset);
          stdinPos += count;
          if (stdinPos === first.length) {
            stdin.shift();
            stdinPos = 0;
          }
          callback(null, count);
        };
        let go = new globalThis.Go();
        go.argv = ["", \`--service=\${"0.25.12"}\`];
        tryToInstantiateModule(wasm, go).then(
          (instance) => {
            postMessage(null);
            go.run(instance);
          },
          (error) => {
            postMessage(error);
          }
        );
        return go;
      };
      function tryToInstantiateModule(wasm, go) {
        return __async(this, null, function* () {
          if (wasm instanceof WebAssembly.Module) {
            return WebAssembly.instantiate(wasm, go.importObject);
          }
          const res = yield fetch(wasm);
          if (!res.ok) throw new Error(\`Failed to download \${JSON.stringify(wasm)}\`);
          if ("instantiateStreaming" in WebAssembly && /^application\\/wasm($|;)/i.test(res.headers.get("Content-Type") || "")) {
            const result2 = yield WebAssembly.instantiateStreaming(res, go.importObject);
            return result2.instance;
          }
          const bytes = yield res.arrayBuffer();
          const result = yield WebAssembly.instantiate(bytes, go.importObject);
          return result.instance;
        });
      }
      return (m) => onmessage(m);
    })(postMessage)`],{type:"text/javascript"});o=new Worker(URL.createObjectURL(U))}else{let U=(M=>{var H=(j,T,g)=>new Promise((f,i)=>{var a=x=>{try{b(g.next(x))}catch(c){i(c)}},d=x=>{try{b(g.throw(x))}catch(c){i(c)}},b=x=>x.done?f(x.value):Promise.resolve(x.value).then(a,d);b((g=g.apply(j,T)).next())});let Y,A={};for(let j=self;j;j=Object.getPrototypeOf(j))for(let T of Object.getOwnPropertyNames(j))T in A||Object.defineProperty(A,T,{get:()=>self[T]});(()=>{const j=()=>{const f=new Error("not implemented");return f.code="ENOSYS",f};if(!A.fs){let f="";A.fs={constants:{O_WRONLY:-1,O_RDWR:-1,O_CREAT:-1,O_TRUNC:-1,O_APPEND:-1,O_EXCL:-1},writeSync(i,a){f+=g.decode(a);const d=f.lastIndexOf(`
`);return d!=-1&&(console.log(f.substring(0,d)),f=f.substring(d+1)),a.length},write(i,a,d,b,x,c){if(d!==0||b!==a.length||x!==null){c(j());return}const p=this.writeSync(i,a);c(null,p)},chmod(i,a,d){d(j())},chown(i,a,d,b){b(j())},close(i,a){a(j())},fchmod(i,a,d){d(j())},fchown(i,a,d,b){b(j())},fstat(i,a){a(j())},fsync(i,a){a(null)},ftruncate(i,a,d){d(j())},lchown(i,a,d,b){b(j())},link(i,a,d){d(j())},lstat(i,a){a(j())},mkdir(i,a,d){d(j())},open(i,a,d,b){b(j())},read(i,a,d,b,x,c){c(j())},readdir(i,a){a(j())},readlink(i,a){a(j())},rename(i,a,d){d(j())},rmdir(i,a){a(j())},stat(i,a){a(j())},symlink(i,a,d){d(j())},truncate(i,a,d){d(j())},unlink(i,a){a(j())},utimes(i,a,d,b){b(j())}}}if(A.process||(A.process={getuid(){return-1},getgid(){return-1},geteuid(){return-1},getegid(){return-1},getgroups(){throw j()},pid:-1,ppid:-1,umask(){throw j()},cwd(){throw j()},chdir(){throw j()}}),!A.crypto)throw new Error("globalThis.crypto is not available, polyfill required (crypto.getRandomValues only)");if(!A.performance)throw new Error("globalThis.performance is not available, polyfill required (performance.now only)");if(!A.TextEncoder)throw new Error("globalThis.TextEncoder is not available, polyfill required");if(!A.TextDecoder)throw new Error("globalThis.TextDecoder is not available, polyfill required");const T=new TextEncoder("utf-8"),g=new TextDecoder("utf-8");A.Go=class{constructor(){this.argv=["js"],this.env={},this.exit=t=>{t!==0&&console.warn("exit code:",t)},this._exitPromise=new Promise(t=>{this._resolveExitPromise=t}),this._pendingEvent=null,this._scheduledTimeouts=new Map,this._nextCallbackTimeoutID=1;const f=(t,l)=>{this.mem.setUint32(t+0,l,!0),this.mem.setUint32(t+4,Math.floor(l/4294967296),!0)},i=t=>{const l=this.mem.getUint32(t+0,!0),y=this.mem.getInt32(t+4,!0);return l+y*4294967296},a=t=>{const l=this.mem.getFloat64(t,!0);if(l===0)return;if(!isNaN(l))return l;const y=this.mem.getUint32(t,!0);return this._values[y]},d=(t,l)=>{if(typeof l=="number"&&l!==0){if(isNaN(l)){this.mem.setUint32(t+4,2146959360,!0),this.mem.setUint32(t,0,!0);return}this.mem.setFloat64(t,l,!0);return}if(l===void 0){this.mem.setFloat64(t,0,!0);return}let v=this._ids.get(l);v===void 0&&(v=this._idPool.pop(),v===void 0&&(v=this._values.length),this._values[v]=l,this._goRefCounts[v]=0,this._ids.set(l,v)),this._goRefCounts[v]++;let C=0;switch(typeof l){case"object":l!==null&&(C=1);break;case"string":C=2;break;case"symbol":C=3;break;case"function":C=4;break}this.mem.setUint32(t+4,2146959360|C,!0),this.mem.setUint32(t,v,!0)},b=t=>{const l=i(t+0),y=i(t+8);return new Uint8Array(this._inst.exports.mem.buffer,l,y)},x=t=>{const l=i(t+0),y=i(t+8),v=new Array(y);for(let C=0;C<y;C++)v[C]=a(l+C*8);return v},c=t=>{const l=i(t+0),y=i(t+8);return g.decode(new DataView(this._inst.exports.mem.buffer,l,y))},p=Date.now()-performance.now();this.importObject={_gotest:{add:(t,l)=>t+l},gojs:{"runtime.wasmExit":t=>{t>>>=0;const l=this.mem.getInt32(t+8,!0);this.exited=!0,delete this._inst,delete this._values,delete this._goRefCounts,delete this._ids,delete this._idPool,this.exit(l)},"runtime.wasmWrite":t=>{t>>>=0;const l=i(t+8),y=i(t+16),v=this.mem.getInt32(t+24,!0);A.fs.writeSync(l,new Uint8Array(this._inst.exports.mem.buffer,y,v))},"runtime.resetMemoryDataView":t=>{this.mem=new DataView(this._inst.exports.mem.buffer)},"runtime.nanotime1":t=>{t>>>=0,f(t+8,(p+performance.now())*1e6)},"runtime.walltime":t=>{t>>>=0;const l=new Date().getTime();f(t+8,l/1e3),this.mem.setInt32(t+16,l%1e3*1e6,!0)},"runtime.scheduleTimeoutEvent":t=>{t>>>=0;const l=this._nextCallbackTimeoutID;this._nextCallbackTimeoutID++,this._scheduledTimeouts.set(l,setTimeout(()=>{for(this._resume();this._scheduledTimeouts.has(l);)console.warn("scheduleTimeoutEvent: missed timeout event"),this._resume()},i(t+8))),this.mem.setInt32(t+16,l,!0)},"runtime.clearTimeoutEvent":t=>{t>>>=0;const l=this.mem.getInt32(t+8,!0);clearTimeout(this._scheduledTimeouts.get(l)),this._scheduledTimeouts.delete(l)},"runtime.getRandomData":t=>{t>>>=0,crypto.getRandomValues(b(t+8))},"syscall/js.finalizeRef":t=>{t>>>=0;const l=this.mem.getUint32(t+8,!0);if(this._goRefCounts[l]--,this._goRefCounts[l]===0){const y=this._values[l];this._values[l]=null,this._ids.delete(y),this._idPool.push(l)}},"syscall/js.stringVal":t=>{t>>>=0,d(t+24,c(t+8))},"syscall/js.valueGet":t=>{t>>>=0;const l=Reflect.get(a(t+8),c(t+16));t=this._inst.exports.getsp()>>>0,d(t+32,l)},"syscall/js.valueSet":t=>{t>>>=0,Reflect.set(a(t+8),c(t+16),a(t+32))},"syscall/js.valueDelete":t=>{t>>>=0,Reflect.deleteProperty(a(t+8),c(t+16))},"syscall/js.valueIndex":t=>{t>>>=0,d(t+24,Reflect.get(a(t+8),i(t+16)))},"syscall/js.valueSetIndex":t=>{t>>>=0,Reflect.set(a(t+8),i(t+16),a(t+24))},"syscall/js.valueCall":t=>{t>>>=0;try{const l=a(t+8),y=Reflect.get(l,c(t+16)),v=x(t+32),C=Reflect.apply(y,l,v);t=this._inst.exports.getsp()>>>0,d(t+56,C),this.mem.setUint8(t+64,1)}catch(l){t=this._inst.exports.getsp()>>>0,d(t+56,l),this.mem.setUint8(t+64,0)}},"syscall/js.valueInvoke":t=>{t>>>=0;try{const l=a(t+8),y=x(t+16),v=Reflect.apply(l,void 0,y);t=this._inst.exports.getsp()>>>0,d(t+40,v),this.mem.setUint8(t+48,1)}catch(l){t=this._inst.exports.getsp()>>>0,d(t+40,l),this.mem.setUint8(t+48,0)}},"syscall/js.valueNew":t=>{t>>>=0;try{const l=a(t+8),y=x(t+16),v=Reflect.construct(l,y);t=this._inst.exports.getsp()>>>0,d(t+40,v),this.mem.setUint8(t+48,1)}catch(l){t=this._inst.exports.getsp()>>>0,d(t+40,l),this.mem.setUint8(t+48,0)}},"syscall/js.valueLength":t=>{t>>>=0,f(t+16,parseInt(a(t+8).length))},"syscall/js.valuePrepareString":t=>{t>>>=0;const l=T.encode(String(a(t+8)));d(t+16,l),f(t+24,l.length)},"syscall/js.valueLoadString":t=>{t>>>=0;const l=a(t+8);b(t+16).set(l)},"syscall/js.valueInstanceOf":t=>{t>>>=0,this.mem.setUint8(t+24,a(t+8)instanceof a(t+16)?1:0)},"syscall/js.copyBytesToGo":t=>{t>>>=0;const l=b(t+8),y=a(t+32);if(!(y instanceof Uint8Array||y instanceof Uint8ClampedArray)){this.mem.setUint8(t+48,0);return}const v=y.subarray(0,l.length);l.set(v),f(t+40,v.length),this.mem.setUint8(t+48,1)},"syscall/js.copyBytesToJS":t=>{t>>>=0;const l=a(t+8),y=b(t+16);if(!(l instanceof Uint8Array||l instanceof Uint8ClampedArray)){this.mem.setUint8(t+48,0);return}const v=y.subarray(0,l.length);l.set(v),f(t+40,v.length),this.mem.setUint8(t+48,1)},debug:t=>{console.log(t)}}}}run(f){return H(this,null,function*(){if(!(f instanceof WebAssembly.Instance))throw new Error("Go.run: WebAssembly.Instance expected");this._inst=f,this.mem=new DataView(this._inst.exports.mem.buffer),this._values=[NaN,0,null,!0,!1,A,this],this._goRefCounts=new Array(this._values.length).fill(1/0),this._ids=new Map([[0,1],[null,2],[!0,3],[!1,4],[A,5],[this,6]]),this._idPool=[],this.exited=!1;let i=4096;const a=t=>{const l=i,y=T.encode(t+"\0");return new Uint8Array(this.mem.buffer,i,y.length).set(y),i+=y.length,i%8!==0&&(i+=8-i%8),l},d=this.argv.length,b=[];this.argv.forEach(t=>{b.push(a(t))}),b.push(0),Object.keys(this.env).sort().forEach(t=>{b.push(a(`${t}=${this.env[t]}`))}),b.push(0);const c=i;if(b.forEach(t=>{this.mem.setUint32(i,t,!0),this.mem.setUint32(i+4,0,!0),i+=8}),i>=12288)throw new Error("total length of command line and environment variables exceeds limit");this._inst.exports.run(d,c),this.exited&&this._resolveExitPromise(),yield this._exitPromise})}_resume(){if(this.exited)throw new Error("Go program has already exited");this._inst.exports.resume(),this.exited&&this._resolveExitPromise()}_makeFuncWrapper(f){const i=this;return function(){const a={id:f,this:this,args:arguments};return i._pendingEvent=a,i._resume(),a.result}}}})(),Y=({data:j})=>{let T=new TextDecoder,g=A.fs,f="";g.writeSync=(x,c)=>{if(x===1)M(c);else if(x===2){f+=T.decode(c);let p=f.split(`
`);p.length>1&&console.log(p.slice(0,-1).join(`
`)),f=p[p.length-1]}else throw new Error("Bad write");return c.length};let i=[],a,d=0;Y=({data:x})=>(x.length>0&&(i.push(x),a&&a()),b),g.read=(x,c,p,t,l,y)=>{if(x!==0||p!==0||t!==c.length||l!==null)throw new Error("Bad read");if(i.length===0){a=()=>g.read(x,c,p,t,l,y);return}let v=i[0],C=Math.max(0,Math.min(t,v.length-d));c.set(v.subarray(d,d+C),p),d+=C,d===v.length&&(i.shift(),d=0),y(null,C)};let b=new A.Go;return b.argv=["","--service=0.25.12"],le(j,b).then(x=>{M(null),b.run(x)},x=>{M(x)}),b};function le(j,T){return H(this,null,function*(){if(j instanceof WebAssembly.Module)return WebAssembly.instantiate(j,T.importObject);const g=yield fetch(j);if(!g.ok)throw new Error(`Failed to download ${JSON.stringify(j)}`);if("instantiateStreaming"in WebAssembly&&/^application\/wasm($|;)/i.test(g.headers.get("Content-Type")||""))return(yield WebAssembly.instantiateStreaming(g,T.importObject)).instance;const f=yield g.arrayBuffer();return(yield WebAssembly.instantiate(f,T.importObject)).instance})}return j=>Y(j)})(M=>o.onmessage({data:M})),K;o={onmessage:null,postMessage:M=>setTimeout(()=>{try{K=U({data:M})}catch(H){m(H)}}),terminate(){if(K)for(let M of K._scheduledTimeouts.values())clearTimeout(M)}}}let h,P;const u=new Promise((U,K)=>{h=U,P=K});o.onmessage=({data:U})=>{o.onmessage=({data:K})=>W(K),U?P(U):h()},o.postMessage(n||new URL(e,location.href).toString());let{readFromStdout:W,service:V}=$t({writeToStdin(U){o.postMessage(U)},isSync:!1,hasFS:!1,esbuild:z});yield u,qe=()=>{o.terminate(),De=void 0,qe=void 0,He=void 0},He={build:U=>new Promise((K,M)=>{w.then(M),V.buildOrContext({callName:"build",refs:null,options:U,isTTY:!1,defaultWD:"/",callback:(H,Y)=>H?M(H):K(Y)})}),context:U=>new Promise((K,M)=>{w.then(M),V.buildOrContext({callName:"context",refs:null,options:U,isTTY:!1,defaultWD:"/",callback:(H,Y)=>H?M(H):K(Y)})}),transform:(U,K)=>new Promise((M,H)=>{w.then(H),V.transform({callName:"transform",refs:null,input:U,options:K||{},isTTY:!1,fs:{readFile(Y,A){A(new Error("Internal error"),null)},writeFile(Y,A){A(null)}},callback:(Y,A)=>Y?H(Y):M(A)})}),formatMessages:(U,K)=>new Promise((M,H)=>{w.then(H),V.formatMessages({callName:"formatMessages",refs:null,messages:U,options:K,callback:(Y,A)=>Y?H(Y):M(A)})}),analyzeMetafile:(U,K)=>new Promise((M,H)=>{w.then(H),V.analyzeMetafile({callName:"analyzeMetafile",refs:null,metafile:typeof U=="string"?U:JSON.stringify(U),options:K,callback:(Y,A)=>Y?H(Y):M(A)})})}}),Vt=z})(R)})(Xe)),Xe.exports}var Ze=an();const on=Xt(Ze),cn=Kt({__proto__:null,default:on},[Ze]),un="/assets/esbuild-BHljloGq.wasm";function pt(R,_){if(R.startsWith("/"))return R.slice(1);const S=_.split("/").filter($=>$),k=R.split("/").filter($=>$);if(R.startsWith("./")||R.startsWith("../")||!R.startsWith("/")){const $=S.slice(0,-1);S.length=0,S.push(...$)}for(const $ of k)$!=="."&&($===".."?S.length>0&&S.pop():S.push($));return S.join("/")}let fn={name:"workspace",setup(R){R.onResolve({filter:/.*/},_=>{if(_.path.startsWith("http://")||_.path.startsWith("https://")||_.path.startsWith("data:"))return;let S=_.path;if(S.startsWith("/")&&(S=S.slice(1)),_.importer&&_.importer!==""){let k=_.importer;k.startsWith("virtual-workspace:")&&(k=k.slice(18));const F=_.path.startsWith("./")||_.path.startsWith("../"),$=S.includes("/"),O=k.startsWith("__build/");F?S=pt(_.path,k):!$&&!O&&(S=pt(S,k))}return{path:S,namespace:"virtual-workspace"}}),R.onLoad({filter:/.*/},async _=>{if(!/^(?!https?:\/\/).+/.test(_.path))return;const S=_.path,k=await Qe.getWorkspace();let F=await k.getResource(S);if(F||(await k.listChildren(!0),F=await k.getResource(S)),!F)throw new Error(`Module not found: ${S}`);const $=await F.getContents(),O=S.split(".").pop()?.toLowerCase();let N;return O==="ts"||O==="tsx"?N=O==="tsx"?"tsx":"ts":O==="js"||O==="jsx"?N=O==="jsx"?"jsx":"js":O==="json"?N="json":O==="css"&&(N="css"),{contents:$,loader:N}})}};class dn{constructor(){this.initialized=!1,this.workspaceCache=null}async getWorkspace(){return this.workspaceCache||(this.workspaceCache=await Qe.getWorkspace()),this.workspaceCache}async init(){this.initialized||(await Ze.initialize({wasmURL:un}),this.initialized=!0)}createBrowserFileCopier(){const _=this.getWorkspace.bind(this),S={"dist/index.js":()=>ce(()=>import("./index-DVD8Miw1.js"),[]),"dist/gs-lib.css":()=>ce(()=>import("./gs-lib-DG1GzKAk.js"),[]),"public/pwa/staticwebapp.config.json":()=>ce(()=>import("./staticwebapp.config-D4wTVvdR.js"),[]),"public/pwa/sw.js":()=>ce(()=>import("./sw-D_2k2L39.js"),[]),"public/pwa/manifest.json":()=>ce(()=>import("./manifest-ua3l4Tcu.js"),[]),"public/index.html":()=>ce(()=>import("./index-DBjD4dFr.js"),[]),"public/pwa/assets/icons/24x24.png":()=>ce(()=>import("./24x24-Bu_QYm8Z.js"),[]),"public/pwa/assets/icons/48x48.png":()=>ce(()=>import("./48x48-DrHeaEQJ.js"),[]),"public/pwa/assets/icons/192x192.png":()=>ce(()=>import("./192x192-Be9eAkr9.js"),[]),"public/pwa/assets/icons/512x512.png":()=>ce(()=>import("./512x512-CpHm9SFP.js"),[]),"public/pwa/assets/icons/icon_24.png":()=>ce(()=>import("./icon_24-Bu_QYm8Z.js"),[]),"public/pwa/assets/icons/icon_48.png":()=>ce(()=>import("./icon_48-DrHeaEQJ.js"),[]),"public/pwa/assets/icons/icon_192.png":()=>ce(()=>import("./icon_192-DkSxEksg.js"),[]),"public/pwa/assets/icons/icon_512.png":()=>ce(()=>import("./icon_512-Dcr9wNXR.js"),[])},k=async(F,$,O,N)=>{const Q=S[F];if(!Q)throw new Error(`No import mapping for ${F}. Make sure gs-lib is built.`);let L;try{const ne=await Q();if(O)L=ne.default,N&&(L=await N(L));else{const ge=ne.default,J=await fetch(ge);if(!J.ok)throw new Error(`Failed to fetch: ${J.statusText}`);L=await J.blob()}}catch(ne){throw new Error(`Failed to copy ${F}: ${ne}. Make sure gs-lib is built (run: npm run build --workspace=@kispace-io/gs-lib)`)}await(await(await _()).getResource($,{create:!0})).saveContents(L),L=void 0};return{async copyTextFile(F,$,O){await k(F,$,!0,O)},async copyBinaryFile(F,$){await k(F,$,!1)}}}async build(_,S=void 0,k){const F=(L,z)=>{k&&(k.currentStep=L,k.message=z)};F(0,"Initializing build system..."),await this.init();const $=await this.getWorkspace(),O={async readFile(L){const z=await $.getResource(L);if(!z)throw new Error(`File not found: ${L}`);return await z.getContents()},async writeFile(L,z){await(await $.getResource(L,{create:!0})).saveContents(z)},async ensureDir(L){await $.getResource(L.endsWith("/")?L:L+"/",{create:!0})},async exists(L){return await $.getResource(L)!==null},async deleteDir(L){const z=await $.getResource(L);z instanceof wt&&await z.delete()}},N=this.createBrowserFileCopier();await ln(_,O,fn,cn,{gsLibCopier:N,cleanAfterBuild:S,copyAssets:async(L,z)=>{const Z=await $.getResource("assets");Z&&await Z.copyTo(`${z}/assets`)}},F),F(0,"Finalizing build..."),$.touch(),k&&(k.message="Build completed successfully!")}async buildMapFile(_,S){const k=JSON.parse(await _.getContents()),F=await Jt(S||".env");mt.runAsync("Building map",async $=>{await et.build({title:_.getName(),gsMap:k,env:F,version:F.VERSION||"0.0.0"},void 0,$)}).then(()=>{gt(" Map files copied to 'dist' folder in your workspace!")}).catch($=>{je(` Map could not be built: ${$}`)})}}const et=new dn;qt.put("buildService",et);const Me=".geospace",hn=".env",pn=["node_modules",".git","dist","build",".next",".cache",".vscode",".idea","coverage",".nyc_output",".parcel-cache",".turbo",".yarn",".pnp",".svelte-kit",".nuxt",".output","target","out",".temp",".tmp"];function mn(R){const _=R.toLowerCase();return pn.some(S=>_===S.toLowerCase())}async function Ke(R,_,S,k={value:0}){const F=[],$=await R.listChildren(!0);for(const O of $){k.value++;const N=O.getWorkspacePath();if(S&&(S.message=`Scanning: ${N}`,S.currentStep=k.value),O instanceof Be&&O.getName().toLowerCase().endsWith(_))F.push(N);else if(O instanceof wt&&!mn(O.getName())){const Q=await Ke(O,_,S,k);F.push(...Q)}}return F.sort()}function gn(){let R=document.getElementById("global-dialog-container");return R||(R=document.createElement("div"),R.id="global-dialog-container",document.body.appendChild(R)),R}async function wn(R,_,S,k){return new Promise(F=>{const $=gn();let O=S||"",N=k||"";const Q=()=>{ut(Ye``,$)},L=()=>{Q(),F({geospaceFile:O||null,envFile:N||null})},z=()=>{Q(),F({geospaceFile:null,envFile:null})},Z=Ye`
            <wa-dialog label="Select Files" open @wa-request-close=${z}>
                <style>
                    .dialog-content {
                        display: flex;
                        flex-direction: column;
                        gap: 1.5rem;
                        padding: 1rem;
                        min-width: 400px;
                    }
                    
                    .dialog-field {
                        display: flex;
                        flex-direction: column;
                        gap: 0.5rem;
                    }
                    
                    .dialog-field label {
                        font-weight: 500;
                        color: var(--wa-color-neutral-700);
                    }
                    
                    .dialog-actions {
                        display: flex;
                        gap: 0.5rem;
                        justify-content: flex-end;
                        margin-top: 0.5rem;
                    }
                </style>
                
                <div class="dialog-content">
                    <div class="dialog-field">
                        <label>Geospace File:</label>
                        <wa-select 
                            value="${O}"
                            @change=${ne=>{O=ne.target.value}}>
                            <wa-option value="">None</wa-option>
                            ${R.map(ne=>Ye`
                                <wa-option value="${ne}">${ne}</wa-option>
                            `)}
                        </wa-select>
                    </div>
                    
                    <div class="dialog-field">
                        <label>Environment File:</label>
                        <wa-select 
                            value="${N}"
                            @change=${ne=>{N=ne.target.value}}>
                            <wa-option value="">None (use .env)</wa-option>
                            ${_.map(ne=>Ye`
                                <wa-option value="${ne}">${ne}</wa-option>
                            `)}
                        </wa-select>
                    </div>
                    
                    <div class="dialog-actions">
                        <wa-button variant="default" @click=${z}>
                            Cancel
                        </wa-button>
                        <wa-button variant="primary" @click=${L}>
                            OK
                        </wa-button>
                    </div>
                </div>
            </wa-dialog>
        `;ut(Z,$)})}const En=({commandRegistry:R})=>{R.registerAll({command:{id:"build_map",name:"Build map",description:"Builds a publishable map from a .geospace file",parameters:[{name:"file",description:"Path to the .geospace file relative to workspace root. If not provided, uses the active map editor or selected file.",required:!1},{name:"env",description:"Path to the environment file relative to workspace root (e.g., 'dev.env', 'prod.env'). Defaults to '.env' if not specified.",required:!1},{name:"ask",description:"If true, prompts for missing files (map file or env file) when not provided.",required:!1}]},handler:{execute:async _=>{let S=_.params?.env,k=_.params?.file;const F=_.params?.ask===!0||_.params?.ask==="true",$=await Qe.getWorkspace();if(!$){je("No workspace available");return}let O;if(k){const N=await $.getResource(k);if(!N||!(N instanceof Be)){je(`File not found: ${k}`);return}if(!N.getName().toLowerCase().endsWith(Me)){je(`File is not a .geospace file: ${k}`);return}O=N}else{const N=ft.get();if(N&&N.input)N.isDirty()&&(await N.save(),gt("Map saved automatically to run build.")),O=N.input.data;else{const Q=dt.get();Q instanceof Be&&Q.getName().toLowerCase().endsWith(Me)&&(O=Q)}}if(F&&(!O||!S)){let N=[],Q=[];await mt.runAsync("Collecting files",async Z=>{Z.message="Scanning workspace for .geospace files...",N=await Ke($,Me,Z,{value:0}),Z.message="Scanning workspace for .env files...",Z.currentStep=0,Q=await Ke($,hn,Z,{value:0}),Z.message=`Found ${N.length} .geospace files and ${Q.length} .env files`});const L=O?.getWorkspacePath(),z=await wn(N,Q,L,S||".env");if(z.geospaceFile===null&&z.envFile===null)return;if(z.geospaceFile&&!O){k=z.geospaceFile;const Z=await $.getResource(k);if(!Z||!(Z instanceof Be)){je(`File not found: ${k}`);return}if(!Z.getName().toLowerCase().endsWith(Me)){je(`File is not a .geospace file: ${k}`);return}O=Z}z.envFile!==null&&(S=z.envFile||".env")}else if(!O){je("No map editor active, no .geospace file selected, and no file path provided");return}if(!O){je("No map file available");return}return et.buildMapFile(O,S)}},contribution:{target:"toolbar:map-editor",icon:"hammer",label:"Build map",disabled:()=>!(ft.get()instanceof Ht)}}),Yt.registerContribution("contextmenu:filebrowser",{command:"build_map",icon:"hammer",label:"Build map",params:{ask:!0},disabled:()=>{const _=dt.get();return _ instanceof Be?!_.getName().toLowerCase().endsWith(Me):!0}})};export{En as default};
